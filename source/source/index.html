<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Code description - DuoDMXL</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Code description";
    var mkdocs_page_input_path = "source\\source.md";
    var mkdocs_page_url = "/source/source/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> DuoDMXL</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../..">Home</a>
        
    </li>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Source Code</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../overview/">Overview of the library</a>
        
    </li>

        
            
    <li class="toctree-l1 current">
        <a class="current" href="./">Code description</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#basic-functions">Basic functions</a></li>
                
            
                <li class="toctree-l3"><a href="#functions-related-to-the-eeprom-area-of-the-servos">Functions related to the EEPROM area of the servos</a></li>
                
            
                <li class="toctree-l3"><a href="#functions-related-to-the-ram-area-of-the-servos">Functions related to the RAM area of the servos</a></li>
                
            
                <li class="toctree-l3"><a href="#custom-functions">Custom Functions</a></li>
                
            
            </ul>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Hardware</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../hardware/Duo_TristateBuffer_shield/">Duo Tri-state Buffer Shield</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../hardware/Duo_Rs485_shield/">Duo RS-485 Shield</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <ul class="subnav">
    <li><span>Examples and Tests</span></li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../examples/example0/">Example 0</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../examples/example1/">Example 1</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../examples/example2/">Example 2</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../examples/example3/">Example 3</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../examples/example4/">Example 4</a>
        
    </li>

        
            
    <li class="toctree-l1 ">
        <a class="" href="../../examples/tests/">Tests</a>
        
    </li>

        
    </ul>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../../about/">About</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">DuoDMXL</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>Source Code &raquo;</li>
        
      
    
    <li>Code description</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h2 id="basic-functions">Basic functions</h2>
<p>This set of functions are intended to work <strong>behind the scenes</strong>.
In other words, the user should not have to worry about them.
They deal with low-level communication and are called by other functions.</p>
<p><code>int DynamixelClass::readInformation(void)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">General function to read the status package from a servo. It then extracts the error (if any) or desired data (for example, if the current positon of a servo was requested)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left"><strong>Private</strong> function. Not available to the user</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">None</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">A number representing an error or data</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::sendWord(uint8_t ID, uint8_t address, int param, int noParams)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set the value of a servo's address. noParams should be ONE_BYTE or TWO_BYTES, depending on how many bytes we need to send</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.sendWord(ID, address, param, noParams)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: ID of the servo</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t address: Address to write to.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int param: Value to write to the servo's address</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int noParams: Number of bytes to write (one or two bytes)</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">A number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readWord(uint8_t ID, uint8_t address, int noParams)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the value of a servo's address. noParams should be ONE_BYTE or TWO_BYTES, depending on how many bytes we need</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.readWord(ID, address, noParams)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: ID of the servo</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t address: Address to read from.</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int noParams: Number of bytes to read (one or two bytes)</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">A number representing an error (if any) or the desired data</td>
</tr>
</tbody>
</table>
<p>For example, to change the ID of a servo, a new ID should be written to the register's address 0x03.
This can be accomplished quickly and cleanly with the following code:</p>
<pre><code class="cpp">int DynamixelClass::setID(uint8_t ID, uint8_t newID){
    return(sendWord(ID, EEPROM_ID, newID, ONE_BYTE));
}
</code></pre>

<p>This should make it easier for the user to write custom functions. The hierarchy of the library is shown (simplified) in the following picture.</p>
<p><img alt="communicationHierarchy.png" src="../../img/communicationHierarchy.png" title="Library hierarchy" /></p>
<h2 id="functions-related-to-the-eeprom-area-of-the-servos">Functions related to the EEPROM area of the servos</h2>
<p><code>void DynamixelClass::begin(long baud, uint8_t directionPin)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Initialize communication with the servos with a user-defined pin for the data direction control</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.begin(baud, directionPin)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">long baud: Desired baudrate for communication with the servos. For MX-64AR the default baudrate is 1Mbps (if I remember correctly)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t directionPin: direction used for flow control.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
<p><code>void DynamixelClass::begin(long baud)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Initialize communication with the servos with a pre-defined pin (D15) for the data direction control</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.begin(baud)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">long baud: Desired baudrate for communication with the servos.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
<p><code>void DynamixelClass::end()</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">End communication with the servos</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.end()</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">None</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readModel(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the servo model. EEPROM Address 0(x00) and 1(0x01)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">model = Dynamixel.readModel(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: ID of the servo</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">ID of the servo</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readFirmware(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the version of the firmware. EEPROM Address 2(0x02)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">fw = Dynamixel.readFirmware(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: ID of the servo</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing the firmware version of the servo</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setID(uint8_t ID, uint8_t newID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set the ID of the servo. EEPROM Address 3(0x03)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setID(ID, newID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t newID: New ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readID(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the ID of the servo. EEPROM Address 3(0x03)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">id = Dynamixel.readID(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Current ID of the servo</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setBD(uint8_t ID, long baud)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set baudrate. EEPROM Address 4(0x04)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setBD(ID, baud)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">long baud: Desired baudrate for communication. Up to 1Mbps (use 1000000) is officially supported by the servos. This functions truncates the number so there may be a small error on the final value.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setBDTable(uint8_t ID, uint8_t baud)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set baudrate based on the manual's table. EEPROM Address 4(0x04). This is a more precise value. For example, for communication at 57600 bps use '34'.</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setBDTable(ID, baud)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t baud: Number from 0 to 255 representing a desired baudrate for communication</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readBD(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the setting of the baudrate. EEPROM Address 4(0x04)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">baudrate = Dynamixel.readBD(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number from 0 to 255 representing the baudrate currently being used</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setRDT(uint8_t ID, uint8_t RDT)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set the Return Delay Time (RDT) in microseconds. EEPROM Address 5(0x05)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setRDT(ID, RDT)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t RDT: Desired RDT value</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readRDT(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the Return Delay Time (RDT) value. EEPROM Address 5(0x05)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">rdt = Dynamixel.readRDT(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Current value of RDT</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setCWAngleLimit(uint8_t ID, int limit)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set the value for the CW Angle limit. EEPROM Address 6(0x06) and 7(0x07)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setCWAngleLimit(ID, limit)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int limit: Desired limit</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readCWAngleLimit(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the value for the CW Angle limit. EEPROM Address 6(0x06) and 7(0x07)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">cwLimit = Dynamixel.readCWAngleLimit(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Angle being used for clockwise limit of the servo</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setCCWAngleLimit(uint8_t ID, int limit)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set the value for the CCW Angle limit. EEPROM Address 8(0x08) and 9(0x09)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setCCWAngleLimit(ID, limit)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int limit: Desired limit</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readCCWAngleLimit(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the value for the CCW Angle limit. EEPROM Address 8(0x08) and 9(0x09)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">ccwLimit = Dynamixel.readCCWAngleLimit(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Angle being used for counter-clockwise limit of the servo</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setTempLimit(uint8_t ID, uint8_t Temperature)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set the limit temperature. EEPROM Address 11(0x0B)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setTempLimit(ID, Temperature)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t Temperature: Temperature that will be set as limit. The servo will shutdown if this temperature is reached. Documentation suggests not modifying the default value.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readTempLimit(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the limit temperature. EEPROM Address 11(0x0B)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">tempLimit = Dynamixel.readTempLimit(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Temperature used as upper limit</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setLowVoltageLimit(uint8_t ID, uint8_t lowVoltage)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set the lowest voltage limit. EEPROM Address 12(0x0C)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setLowVoltageLimit(ID, lowVoltage)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t lowVoltage: Lower bound for voltage limit</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readLowVoltageLimit(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the lowest voltage limit. EEPROM Address 12(0x0C)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">lowVoltageLimit = Dynamixel.readLowVoltageLimit(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Lower bound voltage</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setHighVoltageLimit(uint8_t ID, uint8_t highVoltage)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set the highest voltage limit. EEPROM Address 13(0x0D)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setHighVoltageLimit(ID, highVoltage)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t highVoltage: Upper bound for voltage limit</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readHighVoltageLimit(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the highest voltage limit. EEPROM Address 13(0x0D)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">highVoltageLimit = Dynamixel.readHighVoltageLimit(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Upper bound voltage</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setMaxTorque(uint8_t ID, int MaxTorque)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set the maximum torque. EEPROM Address 14(0x0E) and 15(0x0F)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setMaxTorque(ID, MaxTorque)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int MaxTorque: Value from [0, 1023] used for maximum output torque.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readMaxTorque(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the maximum torque. EEPROM Address 14(0x0E) and 15(0x0F)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">maxTorque = Dynamixel.readMaxTorque(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Value from [0, 1023] representing the maximum output torque currently used.</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setSRL(uint8_t ID, uint8_t SRL)</code></p>
<p>Improved functionality in <strong>DuoDMXL</strong> v.0.3.</p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set the Status Return Level. EEPROM Address 16(0x10)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setSRL(ID, SRL)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t SRL: 0, 1, or 2 for 'no return against all commands', 'return only for the READ command', or 'Return for all commands', respectively.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p>As of <strong>DuoDMXL</strong> v.0.3 the user can choose any SRL.
However, <strong>DuoDMXL</strong> assumes on reset that all servos have the same SRL and ALL communications return a package (i.e., <code>SRL=2</code>).
If you changed the value of SRL on a previous session, there may be problems with the communication, since the value of SRL is written in the EEPROM memory of the servos.
If you are having troubles with communication use:</p>
<pre><code class="cpp">    Dynamixel.begin(baud, dataPin);
    delay(500);
    Dynamixel.setSRL(254, 2);
</code></pre>

<p>at the beginning of your program to set all servos to 'Return for all commands'.</p>
<p><strong>NOTE</strong>: <code>254</code> is the broadcast ID. Any command is sent to all servos.</p>
<p><code>int DynamixelClass::readSRL(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the Status Return Level value. EEPROM Address 16(0x10)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">srl = Dynamixek.readSRL(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Actual value of the SRL address</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setAlarmLED(uint8_t ID, uint8_t alarm)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set Alarm LED. EEPROM Address 17(0x11)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setAlarmLED(ID, alarm)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t alarm: The servo's LED will blink if an error occurs</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readAlarmLED(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read Alarm LED value. EEPROM Address 17(0x11)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">alarm = Dynamixel.readAlarmLED(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Actual value of the alarm address</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setShutdownAlarm(uint8_t ID, uint8_t SALARM)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set Shutdown alarm. EEPROM Address 18(0x12)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setShutdownAlarm(ID, SALARM)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t SALARM: Check the documentation. Depending on the value sent, the servo will output a 0% torque if an alarm is activated. By default the value is 36 (0x24) which in binary is '0010 0100', meaning overload+overheating error.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><img alt="errors.png" src="../../img/errors.png" title="possible errors" /></p>
<p><code>int DynamixelClass::readShutdownAlarm(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read Shutdown alarm value. EEPROM Address 18(0x12)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">alarm = Dynamixel.readShutdownAlarm(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Read the value of the alarm address to verify if an alarm was activated</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setMultiTurnOffset(uint8_t ID, int offset)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set the multi-turn offset values. EEPROM ADDRESS: 20(0x14) and 21(0x15)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setMultiTurnOffset(ID, offset)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int offset: Angle used for servo's offset in multi-turn mode</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readMultiTurnOffset(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the multi-turn offset values. EEPROM ADDRESS: 20(0x14) and 21(0x15)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">offset = Dynamixel.readMultiTurnOffset(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Read the actual offset being used for multi-turn mode</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setResolutionDivider(uint8_t ID, uint8_t divider)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set the resolution divider value. EEPROM ADDRESS: 22(0x16)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setResolutionDivider(ID, divider)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t divider: Divider for the servo's angle. By default divider=1</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readResolutionDivider(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the resolution divider value. EEPROM ADDRESS: 22(0x16)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">divider = Dynamixel.readResolutionDivider(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Actual value used for the servo's divider</td>
</tr>
</tbody>
</table>
<h2 id="functions-related-to-the-ram-area-of-the-servos">Functions related to the RAM area of the servos</h2>
<p><code>int DynamixelClass::torqueEnable( uint8_t ID, bool Status)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to turn ON or OFF torque. RAM Address 24(0x18)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.torqueEnable(ID, Status)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">bool Status: True or False for enabling or disabling torque, respectively.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::torqueEnableStatus( uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to check if the servo generates torque. RAM Address 24(0x18)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">status = Dynamixel.torqueEnableStatus(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">1 if torque is enabled. 0 if disabled</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::ledStatus(uint8_t ID, bool Status)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to turn ON or OFF the servo's LED. RAM Address 25(0x19)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.ledStatus(ID, Status)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">bool Status: True or False for enabling or disabling the LED, respectively. I do not provide a function to read this register, so <strong>visual confirmation</strong> should be used.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setGainD(uint8_t ID, int gain)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set the value of the Derivative gain. RAM Address 26(0x1A)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setGainD(ID, gain)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int gain: Number [0,254] used for the Derivative gain of the servo. Related to the servo's PID control</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readGainD(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the value of the Derivative gain. RAM Address 26(0x1A)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">gainD = Dynamixel.readGainD(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Derivative gain</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setGainI(uint8_t ID, int gain)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set the value of the Integral gain. RAM Address 27(0x1B)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setGainI(ID, gain)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int gain: Number [0,254] used for the Integral gain of the servo. Related to the servo's PID control</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readGainI(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the value of the Integral gain. RAM Address 27(0x1B)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">gainI = Dynamixel.readGainI(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Integral gain</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setGainP(uint8_t ID, int gain)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set the value of the Proportional gain. RAM Address 28(0x1C)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setGainP(ID, gain)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int gain: Number [0,254] used for the Proportional gain of the servo. Related to the servo's PID control</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readGainP(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the value of the Proportional gain. RAM Address 28(0x1C)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">gainP = Dynamixel.readGainP(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Proportional gain</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::move(uint8_t ID, int Position)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to move servo to a specific position. RAM Address 30(0x1E) and 31(0x1F)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.move(ID, Position)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int Position: Number [0,4095] representing the desired position. The unit is about 0.088 degrees</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setMovingSpeed(uint8_t ID, int speed)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set the desired moving speed. RAM Address 32(0x20) and 33(0x21)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setMovingSpeed(ID, speed)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int speed: Number [0,1023] representing moving speed. The unit is about 0.114 rpm.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readMovingSpeed(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the desired moving speed. RAM Address 32(0x20) and 33(0x21)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">speed = Dynamixel.readMovingSpeed(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Moving speed value in the register</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setTorqueLimit(uint8_t ID, int torque)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set the value of the goal torque. RAM Address 34(0x22) and 35(0x23)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setTorqueLimit(ID, torque)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int torque: Number [0,1023] used for torque limit. The servo will not exert a higher torque. According to documentation, if the motor is disabled due to activating an alarm, this register will be set to 0. To re-enable the servo set a non-zero value. When the motor is turned on, the torque limit will take the value currently written in the EEPROM address 0x0E. Check the function <strong>setMaxTorque()</strong> if you want to change this value.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readTorqueLimit(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the value of the goal torque. RAM Address 34(0x22) and 35(0x23)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">torqueLimit = readTorqueLimit(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Torque limit value [0,1023]</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readPosition(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the actual position. RAM Address 36(0x24) and 37(0x25)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">pos = Dynamixel.readPosition(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">The actual position of the servo</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readSpeed(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the actual speed. RAM Address 38(0x26) and 39(0x27)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">speed = Dynamixel.readSpeed(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">The actual speed of the servo (possible values [0,2047]). [0,1023] correspond to CCW and [1024,2047] to CW speeds, respectively. In other words, the magnitude is given by the first nine bits [0,1023] and the tenth bit denotes the direction.</td>
</tr>
</tbody>
</table>
<p><img alt="present_speed.png" src="../../img/present_speed.png" title="possible speed" /></p>
<p><code>int DynamixelClass::readLoad(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the load. RAM Address 40(0x28) and 41(0x29)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">load = Dynamixel.readLoad(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">Reads the currently applied load. However, according to documentation, this value is inferred from the internal torque value and should not be used for accurate torque measurement. It is better to read the current.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">The currently applied load. If the load is CCW the value will be [0,1023] and of CW then [1024,2047]</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readVoltage(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the voltage. RAM Address 42(0x2A)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">voltage = Dynamixel.readVoltage(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">(10 times) The actual voltage</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readTemperature(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the Temperature. RAM Address 43(0x2B)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">temp = Dynamixel.readTemperature(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Actual temperature of the servo (Celsius degrees)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::registeredStatus(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Check if there is an instruction registered. RAM Address 44(0x2C)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">status = Dyunamixel.registeredStatus(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">0 if there are no commands registered, and 1 otherwise</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::moving(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Check if goal position command is being executed (Address 0x30?). RAM Address 46(0x2E)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">moving = Dynamixel.moving(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">0 if the servo is not moving and 1 if otherwise</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::lockEEPROM(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Locks the EEPROM area. RAM Address 47(0x2F). Power must be turned off to reset it</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.lockEEPROM(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setPunch(uint8_t ID, int Punch)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">RAM Address 48(0x30) and 49(0x31). Honestly, I do not understand this feature even after reading the documentation</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setPunch(ID, Punch)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int Punch: number [0,1023]</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readPunch(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Reads the value of RAM Address 48(0x30) and 49(0x31). See the note in <strong>setPunch()</strong></td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">punch = Dynamixel.readPunch(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">punch</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readCurrent(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to read the current. RAM ADDRESS: 68(0x44) and 69(0x45)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">current = Dynamixel.readCurrent(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Actual current running through the servo</td>
</tr>
</tbody>
</table>
<p>TODO: Add picture</p>
<p><code>int DynamixelClass::torqueControl( uint8_t ID, bool enable)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Torque control mode enable. RAM ADDRESS: 70(0x46). The servo can run continuously trying to achieve the desired (goal) torque. See <strong>setGoalTorque()</strong>. When torque mode is enabled, you can no longer control the servo's positon.</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.torqueControl(ID, enable)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID : Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">bool enable: <strong>True</strong> for enabling and <strong>False</strong> for disabling</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::readTorqueControl( uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Read the Torque control mode status. RAM ADDRESS: 70(0x46)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">status = Dynamixel.readTorqueControl(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID : Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">1 if torque mode is enabled and 0 otherwise</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::setGoalTorque(uint8_t ID, int torque)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set the goal torque. RAM ADDRESS: 71(0x47) and 72(0x48). In reality you are setting a desired current and the torque will be proportional</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setGoalTorque(ID, torque)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID : Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int torque: [0,1023] for CCW torque and [1024,2047] for CW. The unit is 4.5 [mA]. The goal torque value cannot be bigger than the torque limit value</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<p>TODO: Add picture</p>
<p><code>int DynamixelClass::setGoalAccel(uint8_t ID, uint8_t accel)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set goal acceleration/ RAM ADDRESS: 73(0x49)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setGoalAccel(ID, accel)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID : Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t accel: desired acceleration [0,254]</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Number representing an error (if any)</td>
</tr>
</tbody>
</table>
<h2 id="custom-functions">Custom Functions</h2>
<p>These functions build upon the previous ones to provide more advanced functionality.
In particular there are several functions in order to find your connected servo in case you don't know its ID or the baudrate it is communicating with.
This is very useful for debugging new code that may overwrite a register accidentaly.
For example, if you can' remember your servo's ID or don't know the baudrate it is using, and you do not have the USB2Dynamixel product to debug your servo, then you can use this functions to find it.
Needless to say, I wrote these functions because at some point I accidentally changed the servo's ID and baudrate to an unknown value and couldn't communicate with it.
Connect only one servo to find it.</p>
<p><code>void DynamixelClass::configureServo(uint8_t ID, uint8_t newID, long baud)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Configure both ID and Baudrate of the servo</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.configureServo(ID, newID, baud)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID : Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t newID : New ID for the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">long baud : New baudrate for communication</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
<p><code>void DynamixelClass::setAngleLimit(uint8_t ID, int CWLimit, int CCWLimit)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Set both angle limits</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setAngleLimit(ID, CWLimit, CCWLimit )</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID : Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int CWLimit: Clockwise limit for the servo</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int CCWLimit: Counter-clockwise limit for the servo</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
<p><code>void DynamixelClass::setWheelMode(uint8_t ID, bool enable)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set both limits to 0. The servo is functioning in wheel mode</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setWheelMode(ID, enable)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">bool enable: Enables or disables servo's wheel mode. If disabled, the servo defaults to the usual [0,4095] range of motion</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
<p><code>void DynamixelClass::setJointMode(uint8_t ID)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set the servo as joint mode. Equivalent to setWheelMode(ID, false)</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setJointMode(ID)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID: Current ID of the servomotor</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
<p><code>void DynamixelClass::setDIP(uint8_t ID, int gainD, int gainI, int gainP)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to set all gains. Be careful with the order</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.setDIP(ID, gainD, gainI, gainP)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t ID : Current ID of the servomotor</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int gainD: Derivative gain</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int gainI: Integral gain</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int gainP: Proportional gain</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::findByBaudRate(long baudRate)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to find the ID of the servo, if you have the correct baudrate. Assume begin() has been called</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">foundID = Dynamixel.findByBaudRate(baudRate)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">long baudRate: baudrate used for communication</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Found ID of the servo. If no servo is found (meaning you have the incorrect baudrate) then the value returned is -1</td>
</tr>
</tbody>
</table>
<p><code>int DynamixelClass::findByID(uint8_t id, uint8_t directionPin)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Function to find the baudrate to communicate with the servo, if you have the correct ID. Assume begin() has NOT been called</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.findByID(id, directionPin)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t id: Current id of the servomotor. This function assumes the ID is correct and you are only trying to find the correct baudrate</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">uint8_t directionPin: The pin used for data flow control.</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">The baudrate (table value [0,255]) representing the baudrate. Returns -1 if the servo was not found</td>
</tr>
</tbody>
</table>
<p><code>void DynamixelClass::findServo(uint8_t directionPin)</code></p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Find the servo without having any information. Assume begin() has NOT been called. The function doesn't return anything but prints the result to the terminal (Use the Arduino IDE built in terminal monitor). This is the last resort to find your servo info. Since it tries all baudrates and IDs, it may take a while</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.findServo(directionPin)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t directionPin: Pin used for flow control</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing. Check the output in the terminal</td>
</tr>
</tbody>
</table>
<p><code>void DynamixelClass::changeTimeOut(uint8_t newTimeOut)</code></p>
<p>Introduced in <strong>DuoDMXL</strong> v.0.3.</p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Change time out period (waiting time for status package). Unit is [ms]. The maximum value is 255. The default value is 50[ms]</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.changeTimeOut(newTimeOut)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint8_t newTimeOut: New time out period</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
<p><code>void DynamixelClass::changeCoolDown(uint16_t newCoolDown)</code></p>
<p>Introduced in <strong>DuoDMXL</strong> v.0.3.</p>
<table>
<thead>
<tr>
<th align="left">Information</th>
<th align="left"></th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Description</td>
<td align="left">Change cool down period (time between sending commands). Unit is [ms]. The maximum value is 65,535 (i.e., 65.535 seconds). The default value is 0[ms]</td>
</tr>
<tr>
<td align="left">Notation</td>
<td align="left">Dynamixel.changeCoolDown(newCoolDown)</td>
</tr>
<tr>
<td align="left">Parameters</td>
<td align="left">uint16_t newCoolDown: New cool down period</td>
</tr>
<tr>
<td align="left">Returns</td>
<td align="left">Nothing</td>
</tr>
</tbody>
</table>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../hardware/Duo_TristateBuffer_shield/" class="btn btn-neutral float-right" title="Duo Tri-state Buffer Shield">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../overview/" class="btn btn-neutral" title="Overview of the library"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../overview/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../hardware/Duo_TristateBuffer_shield/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../../js/theme.js"></script>

</body>
</html>
