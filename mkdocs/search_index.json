{
    "docs": [
        {
            "location": "/",
            "text": "DuoDMXL\n\n\nLibary for servo control with Duo (Redbear) or Photon (Particle)\n\n\nFor the source code visit \ngithub.com/FabReyesMecha/DuoDMXL\n.\n\n\nDuoDMXL is a library for controlling Dynamixel servos using a \nDuo\n (or Photon) as main microcontroller. This library allows the user to write or read all of the possible registers in the servomotors. Specifically, it is meant for MX-64 servomotors. Other models like AX have different EEPROM registers, but the library can be adapted.\n\n\nInitially, the library was based on \nSavage Electronics Library\n, but eventually started to diverge from the original. The original library used timers for several functions, which would lead to troubles using other microcontrollers, different than the Arduino UNO.\n\n\nThe main difference is that communication is delegated to the basic functions:\n\n\n\n\nsendWord()\n which writes a value to a register of the servo.\n\n\nreadWord()\n which reads the current value of a register of the servo.\n\n\nreadInformation()\n which reads a response (set of bytes) from the servomotors. It could be requested information or a simple no-error response.\n\n\n\n\nand all other functions call these basic functions with the appropiate parameters. This not only decreases the code size, but also allows for easier creation of user-defined functions.\n\n\nThe Dynamixel servos have their own protocol for communication, which you can check in the communication section of the \nROBOTIS manual\n. Depending on the servos you are communicating with, you need to transform UART signal from the the Duo (or Photon) unto a half-duples TTL signal for some servos (e.g., MX-64T) which can be done with a tri-state buffer, or use a RS-485 transceiver for servos that use RS-485 bus (e.g., MX-64AR).\n\n\n\n\nOverview of communication. A more complete setup (including power lines) is included in the \nHardware\n section.\n\n\nThe DuoDMXL repository includes eagle schematics and board layouts for two types of 'shields'. The \nDuo Tri-state Buffer Shield\n is used for half-duplex communication. It takes the TX and RX signal from the DUO (or Photon) and the signal of a control pin, and changes it into communication with only one line of data. The \nDuo RS-485 Shield\n is used to communicate with a RS-485 transceiver. It takes the TX and RX signal from the DUO (or Photon) and the signal of a control pin and outputs differential communication through the two signals D+ and D- (also called A and B). The library works equally with both hardware setups.\n\n\nThe pinout of the Duo can be seen in the following picture.\n\n\n\n\nDuo Pinout.\n\n\nIn this picture a \nSMPS2Dynamixel board\n is used for adding external power (recommended for not frying your microcontroller board and for a more stable and uninterrupted performance). The RS-485 transceiver is powered up from the Duo. Since the Duo can be powered up from several sources (e.g., directly on the 3.3V pin, through the VIN pin with a Lipo battery, or through the micro USB connector) I chose to power up the transceiver from the 3.3V pin to always guarantee the same voltage, independently of the source. I used the \nST4485\n as RS-485 transceiver, but you can choose other if the pin mapping is the same (e.g., \nISL32458E\n). Just be careful to choose a transceiver that uses 3.3V for power.\nPin D15 is used for data flow control by default, buy you can choose other pin if you need to.\n\n\nPrerequisites:\n\n\n\n\nHardware:\n\n\nRS-485 transceiver or Tri-state buffer.\n\n\n\n\n\n\nSoftware dependencies:\n\n\nNone (as of version 0.3)\n\n\n\n\n\n\n\n\nInstallation:\nThis library is mainly intended to be used with the Arduino IDE. Just download the source code and install in \n.../documents/Arduino/libraries\n.\n\n\nSections\n\n\n\n\n\n\n\n\nSection\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nHome\n\n\nIntroduction to DuoDMXL\n\n\n\n\n\n\nSource Code\n\n\nDocumentation of the DuoDMXL library.\n\n\n\n\n\n\nHardware\n\n\nDocumentation for the shields necessary to interface the DYNAMIXEL servos with the Duo (RedBear) ot Photon (Particle).\n\n\n\n\n\n\nExamples & Tests\n\n\nExamples of how to use the library DuoDMXL. Data from oscilloscope or logic analyzer are provided for some examples.\n\n\n\n\n\n\n\n\nLog\n\n\n\n\n[2017-05-04]: Uploaded \nDuoDMXL\n v.0.3",
            "title": "Home"
        },
        {
            "location": "/#duodmxl",
            "text": "",
            "title": "DuoDMXL"
        },
        {
            "location": "/#libary-for-servo-control-with-duo-redbear-or-photon-particle",
            "text": "For the source code visit  github.com/FabReyesMecha/DuoDMXL .  DuoDMXL is a library for controlling Dynamixel servos using a  Duo  (or Photon) as main microcontroller. This library allows the user to write or read all of the possible registers in the servomotors. Specifically, it is meant for MX-64 servomotors. Other models like AX have different EEPROM registers, but the library can be adapted.  Initially, the library was based on  Savage Electronics Library , but eventually started to diverge from the original. The original library used timers for several functions, which would lead to troubles using other microcontrollers, different than the Arduino UNO.  The main difference is that communication is delegated to the basic functions:   sendWord()  which writes a value to a register of the servo.  readWord()  which reads the current value of a register of the servo.  readInformation()  which reads a response (set of bytes) from the servomotors. It could be requested information or a simple no-error response.   and all other functions call these basic functions with the appropiate parameters. This not only decreases the code size, but also allows for easier creation of user-defined functions.  The Dynamixel servos have their own protocol for communication, which you can check in the communication section of the  ROBOTIS manual . Depending on the servos you are communicating with, you need to transform UART signal from the the Duo (or Photon) unto a half-duples TTL signal for some servos (e.g., MX-64T) which can be done with a tri-state buffer, or use a RS-485 transceiver for servos that use RS-485 bus (e.g., MX-64AR).   Overview of communication. A more complete setup (including power lines) is included in the  Hardware  section.  The DuoDMXL repository includes eagle schematics and board layouts for two types of 'shields'. The  Duo Tri-state Buffer Shield  is used for half-duplex communication. It takes the TX and RX signal from the DUO (or Photon) and the signal of a control pin, and changes it into communication with only one line of data. The  Duo RS-485 Shield  is used to communicate with a RS-485 transceiver. It takes the TX and RX signal from the DUO (or Photon) and the signal of a control pin and outputs differential communication through the two signals D+ and D- (also called A and B). The library works equally with both hardware setups.  The pinout of the Duo can be seen in the following picture.   Duo Pinout.  In this picture a  SMPS2Dynamixel board  is used for adding external power (recommended for not frying your microcontroller board and for a more stable and uninterrupted performance). The RS-485 transceiver is powered up from the Duo. Since the Duo can be powered up from several sources (e.g., directly on the 3.3V pin, through the VIN pin with a Lipo battery, or through the micro USB connector) I chose to power up the transceiver from the 3.3V pin to always guarantee the same voltage, independently of the source. I used the  ST4485  as RS-485 transceiver, but you can choose other if the pin mapping is the same (e.g.,  ISL32458E ). Just be careful to choose a transceiver that uses 3.3V for power.\nPin D15 is used for data flow control by default, buy you can choose other pin if you need to.  Prerequisites:   Hardware:  RS-485 transceiver or Tri-state buffer.    Software dependencies:  None (as of version 0.3)     Installation:\nThis library is mainly intended to be used with the Arduino IDE. Just download the source code and install in  .../documents/Arduino/libraries .",
            "title": "Libary for servo control with Duo (Redbear) or Photon (Particle)"
        },
        {
            "location": "/#sections",
            "text": "Section  Description      Home  Introduction to DuoDMXL    Source Code  Documentation of the DuoDMXL library.    Hardware  Documentation for the shields necessary to interface the DYNAMIXEL servos with the Duo (RedBear) ot Photon (Particle).    Examples & Tests  Examples of how to use the library DuoDMXL. Data from oscilloscope or logic analyzer are provided for some examples.",
            "title": "Sections"
        },
        {
            "location": "/#log",
            "text": "[2017-05-04]: Uploaded  DuoDMXL  v.0.3",
            "title": "Log"
        },
        {
            "location": "/source/overview/",
            "text": "DuoDMXL Code Overview\n\n\nGeneral idea for communication between microcontroller and Dynamixel servos\n\n\nCommunication is done through a specific protocol for communication which is embedded in the Dynamixel servomotors. The detailed description can be found in \nROBOTIS manual\n. Specifically, to the \nCommunication 1.0\n protocol. The idea is that the microcontroller has to send a \npackage\n with a specific structure (in the Robotis manual they call this \ninstruction packet\n). Then the servo responds back with another series of bytes, structured in a similar manner. The \nresponse\n (or \nstatus packet\n in Robotis documentation) contains an error report and additional data if it was requested (e.g., we asked for the angle of the servo).\n\n\nThe package sent to the servo and the response obtained must have the following structure:\n\n\n\n\nOverview of the communication protocol.\n\n\nBoth the \npackage\n and \nresponse\n always have two bytes as \nheader\n which must be \n0xFF\n (or 255 as base 10 integer). The \ninstruction\n byte refers to the action to perform (write, read, etc.). \nParams\n is a series of bytes including the address that will be accesed on the servomotor and additional information. Do not worry, \nDuoDMXL\n takes care of parsing the package correctly and sending it.\n\n\nThe minimal response obtained for each exhange with the servo will be of six bytes (no data requested). Although the response can be disabled altogether, \nDuoDMXL\n assumes that this response is enabled always. In other words, do not turn it off unless you are willing to tweak the source code.\n\n\nHow to use the library\n\n\nFirst, copy the source files into your Arduino libraries folder. You can find more instructions on the web.\nYour folder structure should look similar to this:\n\n\n../Arduino/\n    libraries/\n        ..\n        DuoDMXL/\n            examples/\n                ..\n            copying.lesser.txt\n            DuoDMXL.cpp\n            DuoDMXL.h\n            keywords.txt\n            library.properties\n            license.txt\n        ..\n\n\n\n\nIf your folder structure is correct, you can find the library in the Arduino IDE in the section \nSketch->Include Library-> DuoDMXL\n:\n\n\n\n\nand you can find the examples in \nFile->Examples->DuoDMXL\n\n\n\n\nThe \nDuoDMXL\n library has to be included in your code:\n\n\n#include <DuoDMXL.h>\n\n\n\n\nwhich defines the \nDynamixelClass()\n class.\nHowever, an instance called \nDynamixel\n is available already.\nFor example, to call the function \nbegin()\n defined in \nDuoDMXL.h\n you can use:\n\n\nDynamixel.begin(baud, dataPin);",
            "title": "Overview of the library"
        },
        {
            "location": "/source/overview/#duodmxl-code-overview",
            "text": "",
            "title": "DuoDMXL Code Overview"
        },
        {
            "location": "/source/overview/#general-idea-for-communication-between-microcontroller-and-dynamixel-servos",
            "text": "Communication is done through a specific protocol for communication which is embedded in the Dynamixel servomotors. The detailed description can be found in  ROBOTIS manual . Specifically, to the  Communication 1.0  protocol. The idea is that the microcontroller has to send a  package  with a specific structure (in the Robotis manual they call this  instruction packet ). Then the servo responds back with another series of bytes, structured in a similar manner. The  response  (or  status packet  in Robotis documentation) contains an error report and additional data if it was requested (e.g., we asked for the angle of the servo).  The package sent to the servo and the response obtained must have the following structure:   Overview of the communication protocol.  Both the  package  and  response  always have two bytes as  header  which must be  0xFF  (or 255 as base 10 integer). The  instruction  byte refers to the action to perform (write, read, etc.).  Params  is a series of bytes including the address that will be accesed on the servomotor and additional information. Do not worry,  DuoDMXL  takes care of parsing the package correctly and sending it.  The minimal response obtained for each exhange with the servo will be of six bytes (no data requested). Although the response can be disabled altogether,  DuoDMXL  assumes that this response is enabled always. In other words, do not turn it off unless you are willing to tweak the source code.",
            "title": "General idea for communication between microcontroller and Dynamixel servos"
        },
        {
            "location": "/source/overview/#how-to-use-the-library",
            "text": "First, copy the source files into your Arduino libraries folder. You can find more instructions on the web.\nYour folder structure should look similar to this:  ../Arduino/\n    libraries/\n        ..\n        DuoDMXL/\n            examples/\n                ..\n            copying.lesser.txt\n            DuoDMXL.cpp\n            DuoDMXL.h\n            keywords.txt\n            library.properties\n            license.txt\n        ..  If your folder structure is correct, you can find the library in the Arduino IDE in the section  Sketch->Include Library-> DuoDMXL :   and you can find the examples in  File->Examples->DuoDMXL   The  DuoDMXL  library has to be included in your code:  #include <DuoDMXL.h>  which defines the  DynamixelClass()  class.\nHowever, an instance called  Dynamixel  is available already.\nFor example, to call the function  begin()  defined in  DuoDMXL.h  you can use:  Dynamixel.begin(baud, dataPin);",
            "title": "How to use the library"
        },
        {
            "location": "/source/source/",
            "text": "Basic functions\n\n\nThis set of functions are intended to work \nbehind the scenes\n.\nIn other words, the user should not have to worry about them.\nThey deal with low-level communication and are called by other functions.\n\n\nint DynamixelClass::readInformation(void)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nGeneral function to read the status package from a servo. It then extracts the error (if any) or desired data (for example, if the current positon of a servo was requested)\n\n\n\n\n\n\nNotation\n\n\nPrivate\n function. Not available to the user\n\n\n\n\n\n\nParameters\n\n\nNone\n\n\n\n\n\n\nReturns\n\n\nA number representing an error or data\n\n\n\n\n\n\n\n\nint DynamixelClass::sendWord(uint8_t ID, uint8_t address, int param, int noParams)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set the value of a servo's address. noParams should be ONE_BYTE or TWO_BYTES, depending on how many bytes we need to send\n\n\n\n\n\n\nNotation\n\n\nDynamixel.sendWord(ID, address, param, noParams)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: ID of the servo\n\n\n\n\n\n\n\n\nuint8_t address: Address to write to.\n\n\n\n\n\n\n\n\nint param: Value to write to the servo's address\n\n\n\n\n\n\n\n\nint noParams: Number of bytes to write (one or two bytes)\n\n\n\n\n\n\nReturns\n\n\nA number representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readWord(uint8_t ID, uint8_t address, int noParams)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the value of a servo's address. noParams should be ONE_BYTE or TWO_BYTES, depending on how many bytes we need\n\n\n\n\n\n\nNotation\n\n\nDynamixel.readWord(ID, address, noParams)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: ID of the servo\n\n\n\n\n\n\n\n\nuint8_t address: Address to read from.\n\n\n\n\n\n\n\n\nint noParams: Number of bytes to read (one or two bytes)\n\n\n\n\n\n\nReturns\n\n\nA number representing an error (if any) or the desired data\n\n\n\n\n\n\n\n\nFor example, to change the ID of a servo, a new ID should be written to the register's address 0x03.\nThis can be accomplished quickly and cleanly with the following code:\n\n\nint DynamixelClass::setID(uint8_t ID, uint8_t newID){\n    return(sendWord(ID, EEPROM_ID, newID, ONE_BYTE));\n}\n\n\n\n\nThis should make it easier for the user to write custom functions. The hierarchy of the library is shown (simplified) in the following picture.\n\n\n\n\nFunctions related to the EEPROM area of the servos\n\n\nvoid DynamixelClass::begin(long baud, uint8_t directionPin)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nInitialize communication with the servos with a user-defined pin for the data direction control\n\n\n\n\n\n\nNotation\n\n\nDynamixel.begin(baud, directionPin)\n\n\n\n\n\n\nParameters\n\n\nlong baud: Desired baudrate for communication with the servos. For MX-64AR the default baudrate is 1Mbps (if I remember correctly)\n\n\n\n\n\n\n\n\nuint8_t directionPin: direction used for flow control.\n\n\n\n\n\n\nReturns\n\n\nNothing\n\n\n\n\n\n\n\n\nvoid DynamixelClass::begin(long baud)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nInitialize communication with the servos with a pre-defined pin (D15) for the data direction control\n\n\n\n\n\n\nNotation\n\n\nDynamixel.begin(baud)\n\n\n\n\n\n\nParameters\n\n\nlong baud: Desired baudrate for communication with the servos.\n\n\n\n\n\n\nReturns\n\n\nNothing\n\n\n\n\n\n\n\n\nvoid DynamixelClass::end()\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nEnd communication with the servos\n\n\n\n\n\n\nNotation\n\n\nDynamixel.end()\n\n\n\n\n\n\nParameters\n\n\nNone\n\n\n\n\n\n\nReturns\n\n\nNothing\n\n\n\n\n\n\n\n\nint DynamixelClass::readModel(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the servo model. EEPROM Address 0(x00) and 1(0x01)\n\n\n\n\n\n\nNotation\n\n\nmodel = Dynamixel.readModel(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: ID of the servo\n\n\n\n\n\n\nReturns\n\n\nID of the servo\n\n\n\n\n\n\n\n\nint DynamixelClass::readFirmware(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the version of the firmware. EEPROM Address 2(0x02)\n\n\n\n\n\n\nNotation\n\n\nfw = Dynamixel.readFirmware(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: ID of the servo\n\n\n\n\n\n\nReturns\n\n\nNumber representing the firmware version of the servo\n\n\n\n\n\n\n\n\nint DynamixelClass::setID(uint8_t ID, uint8_t newID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set the ID of the servo. EEPROM Address 3(0x03)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setID(ID, newID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t newID: New ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readID(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the ID of the servo. EEPROM Address 3(0x03)\n\n\n\n\n\n\nNotation\n\n\nid = Dynamixel.readID(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nCurrent ID of the servo\n\n\n\n\n\n\n\n\nint DynamixelClass::setBD(uint8_t ID, long baud)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set baudrate. EEPROM Address 4(0x04)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setBD(ID, baud)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nlong baud: Desired baudrate for communication. Up to 1Mbps (use 1000000) is officially supported by the servos. This functions truncates the number so there may be a small error on the final value.\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::setBDTable(uint8_t ID, uint8_t baud)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set baudrate based on the manual's table. EEPROM Address 4(0x04). This is a more precise value. For example, for communication at 57600 bps use '34'.\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setBDTable(ID, baud)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t baud: Number from 0 to 255 representing a desired baudrate for communication\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readBD(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the setting of the baudrate. EEPROM Address 4(0x04)\n\n\n\n\n\n\nNotation\n\n\nbaudrate = Dynamixel.readBD(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nNumber from 0 to 255 representing the baudrate currently being used\n\n\n\n\n\n\n\n\nint DynamixelClass::setRDT(uint8_t ID, uint8_t RDT)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet the Return Delay Time (RDT) in microseconds. EEPROM Address 5(0x05)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setRDT(ID, RDT)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t RDT: Desired RDT value\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readRDT(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the Return Delay Time (RDT) value. EEPROM Address 5(0x05)\n\n\n\n\n\n\nNotation\n\n\nrdt = Dynamixel.readRDT(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nCurrent value of RDT\n\n\n\n\n\n\n\n\nint DynamixelClass::setCWAngleLimit(uint8_t ID, int limit)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet the value for the CW Angle limit. EEPROM Address 6(0x06) and 7(0x07)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setCWAngleLimit(ID, limit)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint limit: Desired limit\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readCWAngleLimit(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the value for the CW Angle limit. EEPROM Address 6(0x06) and 7(0x07)\n\n\n\n\n\n\nNotation\n\n\ncwLimit = Dynamixel.readCWAngleLimit(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nAngle being used for clockwise limit of the servo\n\n\n\n\n\n\n\n\nint DynamixelClass::setCCWAngleLimit(uint8_t ID, int limit)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet the value for the CCW Angle limit. EEPROM Address 8(0x08) and 9(0x09)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setCCWAngleLimit(ID, limit)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint limit: Desired limit\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readCCWAngleLimit(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the value for the CCW Angle limit. EEPROM Address 8(0x08) and 9(0x09)\n\n\n\n\n\n\nNotation\n\n\nccwLimit = Dynamixel.readCCWAngleLimit(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nAngle being used for counter-clockwise limit of the servo\n\n\n\n\n\n\n\n\nint DynamixelClass::setTempLimit(uint8_t ID, uint8_t Temperature)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet the limit temperature. EEPROM Address 11(0x0B)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setTempLimit(ID, Temperature)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t Temperature: Temperature that will be set as limit. The servo will shutdown if this temperature is reached. Documentation suggests not modifying the default value.\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readTempLimit(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the limit temperature. EEPROM Address 11(0x0B)\n\n\n\n\n\n\nNotation\n\n\ntempLimit = Dynamixel.readTempLimit(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nTemperature used as upper limit\n\n\n\n\n\n\n\n\nint DynamixelClass::setLowVoltageLimit(uint8_t ID, uint8_t lowVoltage)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet the lowest voltage limit. EEPROM Address 12(0x0C)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setLowVoltageLimit(ID, lowVoltage)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t lowVoltage: Lower bound for voltage limit\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readLowVoltageLimit(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the lowest voltage limit. EEPROM Address 12(0x0C)\n\n\n\n\n\n\nNotation\n\n\nlowVoltageLimit = Dynamixel.readLowVoltageLimit(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nLower bound voltage\n\n\n\n\n\n\n\n\nint DynamixelClass::setHighVoltageLimit(uint8_t ID, uint8_t highVoltage)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet the highest voltage limit. EEPROM Address 13(0x0D)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setHighVoltageLimit(ID, highVoltage)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t highVoltage: Upper bound for voltage limit\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readHighVoltageLimit(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the highest voltage limit. EEPROM Address 13(0x0D)\n\n\n\n\n\n\nNotation\n\n\nhighVoltageLimit = Dynamixel.readHighVoltageLimit(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nUpper bound voltage\n\n\n\n\n\n\n\n\nint DynamixelClass::setMaxTorque(uint8_t ID, int MaxTorque)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet the maximum torque. EEPROM Address 14(0x0E) and 15(0x0F)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setMaxTorque(ID, MaxTorque)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint MaxTorque: Value from [0, 1023] used for maximum output torque.\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readMaxTorque(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the maximum torque. EEPROM Address 14(0x0E) and 15(0x0F)\n\n\n\n\n\n\nNotation\n\n\nmaxTorque = Dynamixel.readMaxTorque(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nValue from [0, 1023] representing the maximum output torque currently used.\n\n\n\n\n\n\n\n\nint DynamixelClass::setSRL(uint8_t ID, uint8_t SRL)\n\n\nImproved functionality in \nDuoDMXL\n v.0.3.\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet the Status Return Level. EEPROM Address 16(0x10)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setSRL(ID, SRL)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t SRL: 0, 1, or 2 for 'no return against all commands', 'return only for the READ command', or 'Return for all commands', respectively.\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nAs of \nDuoDMXL\n v.0.3 the user can choose any SRL.\nHowever, \nDuoDMXL\n assumes on reset that all servos have the same SRL and ALL communications return a package (i.e., \nSRL=2\n).\nIf you changed the value of SRL on a previous session, there may be problems with the communication, since the value of SRL is written in the EEPROM memory of the servos.\nIf you are having troubles with communication use:\n\n\n    Dynamixel.begin(baud, dataPin);\n    delay(500);\n    Dynamixel.setSRL(254, 2);\n\n\n\n\nat the beginning of your program to set all servos to 'Return for all commands'.\n\n\nNOTE\n: \n254\n is the broadcast ID. Any command is sent to all servos.\n\n\nint DynamixelClass::readSRL(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the Status Return Level value. EEPROM Address 16(0x10)\n\n\n\n\n\n\nNotation\n\n\nsrl = Dynamixek.readSRL(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nActual value of the SRL address\n\n\n\n\n\n\n\n\nint DynamixelClass::setAlarmLED(uint8_t ID, uint8_t alarm)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet Alarm LED. EEPROM Address 17(0x11)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setAlarmLED(ID, alarm)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t alarm: The servo's LED will blink if an error occurs\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readAlarmLED(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead Alarm LED value. EEPROM Address 17(0x11)\n\n\n\n\n\n\nNotation\n\n\nalarm = Dynamixel.readAlarmLED(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nActual value of the alarm address\n\n\n\n\n\n\n\n\nint DynamixelClass::setShutdownAlarm(uint8_t ID, uint8_t SALARM)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet Shutdown alarm. EEPROM Address 18(0x12)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setShutdownAlarm(ID, SALARM)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t SALARM: Check the documentation. Depending on the value sent, the servo will output a 0% torque if an alarm is activated. By default the value is 36 (0x24) which in binary is '0010 0100', meaning overload+overheating error.\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\n\n\nint DynamixelClass::readShutdownAlarm(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead Shutdown alarm value. EEPROM Address 18(0x12)\n\n\n\n\n\n\nNotation\n\n\nalarm = Dynamixel.readShutdownAlarm(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nRead the value of the alarm address to verify if an alarm was activated\n\n\n\n\n\n\n\n\nint DynamixelClass::setMultiTurnOffset(uint8_t ID, int offset)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet the multi-turn offset values. EEPROM ADDRESS: 20(0x14) and 21(0x15)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setMultiTurnOffset(ID, offset)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint offset: Angle used for servo's offset in multi-turn mode\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readMultiTurnOffset(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the multi-turn offset values. EEPROM ADDRESS: 20(0x14) and 21(0x15)\n\n\n\n\n\n\nNotation\n\n\noffset = Dynamixel.readMultiTurnOffset(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nRead the actual offset being used for multi-turn mode\n\n\n\n\n\n\n\n\nint DynamixelClass::setResolutionDivider(uint8_t ID, uint8_t divider)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet the resolution divider value. EEPROM ADDRESS: 22(0x16)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setResolutionDivider(ID, divider)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t divider: Divider for the servo's angle. By default divider=1\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readResolutionDivider(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the resolution divider value. EEPROM ADDRESS: 22(0x16)\n\n\n\n\n\n\nNotation\n\n\ndivider = Dynamixel.readResolutionDivider(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nActual value used for the servo's divider\n\n\n\n\n\n\n\n\nFunctions related to the RAM area of the servos\n\n\nint DynamixelClass::torqueEnable( uint8_t ID, bool Status)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to turn ON or OFF torque. RAM Address 24(0x18)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.torqueEnable(ID, Status)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nbool Status: True or False for enabling or disabling torque, respectively.\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::torqueEnableStatus( uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to check if the servo generates torque. RAM Address 24(0x18)\n\n\n\n\n\n\nNotation\n\n\nstatus = Dynamixel.torqueEnableStatus(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\n1 if torque is enabled. 0 if disabled\n\n\n\n\n\n\n\n\nint DynamixelClass::ledStatus(uint8_t ID, bool Status)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to turn ON or OFF the servo's LED. RAM Address 25(0x19)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.ledStatus(ID, Status)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nbool Status: True or False for enabling or disabling the LED, respectively. I do not provide a function to read this register, so \nvisual confirmation\n should be used.\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::setGainD(uint8_t ID, int gain)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set the value of the Derivative gain. RAM Address 26(0x1A)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setGainD(ID, gain)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint gain: Number [0,254] used for the Derivative gain of the servo. Related to the servo's PID control\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readGainD(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the value of the Derivative gain. RAM Address 26(0x1A)\n\n\n\n\n\n\nNotation\n\n\ngainD = Dynamixel.readGainD(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nDerivative gain\n\n\n\n\n\n\n\n\nint DynamixelClass::setGainI(uint8_t ID, int gain)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set the value of the Integral gain. RAM Address 27(0x1B)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setGainI(ID, gain)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint gain: Number [0,254] used for the Integral gain of the servo. Related to the servo's PID control\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readGainI(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the value of the Integral gain. RAM Address 27(0x1B)\n\n\n\n\n\n\nNotation\n\n\ngainI = Dynamixel.readGainI(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nIntegral gain\n\n\n\n\n\n\n\n\nint DynamixelClass::setGainP(uint8_t ID, int gain)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set the value of the Proportional gain. RAM Address 28(0x1C)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setGainP(ID, gain)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint gain: Number [0,254] used for the Proportional gain of the servo. Related to the servo's PID control\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readGainP(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the value of the Proportional gain. RAM Address 28(0x1C)\n\n\n\n\n\n\nNotation\n\n\ngainP = Dynamixel.readGainP(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nProportional gain\n\n\n\n\n\n\n\n\nint DynamixelClass::move(uint8_t ID, int Position)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to move servo to a specific position. RAM Address 30(0x1E) and 31(0x1F)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.move(ID, Position)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint Position: Number [0,4095] representing the desired position. The unit is about 0.088 degrees\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::setMovingSpeed(uint8_t ID, int speed)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set the desired moving speed. RAM Address 32(0x20) and 33(0x21)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setMovingSpeed(ID, speed)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint speed: Number [0,1023] representing moving speed. The unit is about 0.114 rpm.\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readMovingSpeed(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the desired moving speed. RAM Address 32(0x20) and 33(0x21)\n\n\n\n\n\n\nNotation\n\n\nspeed = Dynamixel.readMovingSpeed(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nMoving speed value in the register\n\n\n\n\n\n\n\n\nint DynamixelClass::setTorqueLimit(uint8_t ID, int torque)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set the value of the goal torque. RAM Address 34(0x22) and 35(0x23)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setTorqueLimit(ID, torque)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint torque: Number [0,1023] used for torque limit. The servo will not exert a higher torque. According to documentation, if the motor is disabled due to activating an alarm, this register will be set to 0. To re-enable the servo set a non-zero value. When the motor is turned on, the torque limit will take the value currently written in the EEPROM address 0x0E. Check the function \nsetMaxTorque()\n if you want to change this value.\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readTorqueLimit(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the value of the goal torque. RAM Address 34(0x22) and 35(0x23)\n\n\n\n\n\n\nNotation\n\n\ntorqueLimit = readTorqueLimit(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nTorque limit value [0,1023]\n\n\n\n\n\n\n\n\nint DynamixelClass::readPosition(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the actual position. RAM Address 36(0x24) and 37(0x25)\n\n\n\n\n\n\nNotation\n\n\npos = Dynamixel.readPosition(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nThe actual position of the servo\n\n\n\n\n\n\n\n\nint DynamixelClass::readSpeed(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the actual speed. RAM Address 38(0x26) and 39(0x27)\n\n\n\n\n\n\nNotation\n\n\nspeed = Dynamixel.readSpeed(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nThe actual speed of the servo (possible values [0,2047]). [0,1023] correspond to CCW and [1024,2047] to CW speeds, respectively. In other words, the magnitude is given by the first nine bits [0,1023] and the tenth bit denotes the direction.\n\n\n\n\n\n\n\n\n\n\nint DynamixelClass::readLoad(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the load. RAM Address 40(0x28) and 41(0x29)\n\n\n\n\n\n\nNotation\n\n\nload = Dynamixel.readLoad(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nReads the currently applied load. However, according to documentation, this value is inferred from the internal torque value and should not be used for accurate torque measurement. It is better to read the current.\n\n\n\n\n\n\nReturns\n\n\nThe currently applied load. If the load is CCW the value will be [0,1023] and of CW then [1024,2047]\n\n\n\n\n\n\n\n\nint DynamixelClass::readVoltage(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the voltage. RAM Address 42(0x2A)\n\n\n\n\n\n\nNotation\n\n\nvoltage = Dynamixel.readVoltage(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\n(10 times) The actual voltage\n\n\n\n\n\n\n\n\nint DynamixelClass::readTemperature(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the Temperature. RAM Address 43(0x2B)\n\n\n\n\n\n\nNotation\n\n\ntemp = Dynamixel.readTemperature(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nActual temperature of the servo (Celsius degrees)\n\n\n\n\n\n\n\n\nint DynamixelClass::registeredStatus(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nCheck if there is an instruction registered. RAM Address 44(0x2C)\n\n\n\n\n\n\nNotation\n\n\nstatus = Dyunamixel.registeredStatus(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\n0 if there are no commands registered, and 1 otherwise\n\n\n\n\n\n\n\n\nint DynamixelClass::moving(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nCheck if goal position command is being executed (Address 0x30?). RAM Address 46(0x2E)\n\n\n\n\n\n\nNotation\n\n\nmoving = Dynamixel.moving(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\n0 if the servo is not moving and 1 if otherwise\n\n\n\n\n\n\n\n\nint DynamixelClass::lockEEPROM(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nLocks the EEPROM area. RAM Address 47(0x2F). Power must be turned off to reset it\n\n\n\n\n\n\nNotation\n\n\nDynamixel.lockEEPROM(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::setPunch(uint8_t ID, int Punch)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRAM Address 48(0x30) and 49(0x31). Honestly, I do not understand this feature even after reading the documentation\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setPunch(ID, Punch)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nint Punch: number [0,1023]\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readPunch(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nReads the value of RAM Address 48(0x30) and 49(0x31). See the note in \nsetPunch()\n\n\n\n\n\n\nNotation\n\n\npunch = Dynamixel.readPunch(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\npunch\n\n\n\n\n\n\n\n\nint DynamixelClass::readCurrent(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to read the current. RAM ADDRESS: 68(0x44) and 69(0x45)\n\n\n\n\n\n\nNotation\n\n\ncurrent = Dynamixel.readCurrent(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nActual current running through the servo\n\n\n\n\n\n\n\n\nTODO: Add picture\n\n\nint DynamixelClass::torqueControl( uint8_t ID, bool enable)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nTorque control mode enable. RAM ADDRESS: 70(0x46). The servo can run continuously trying to achieve the desired (goal) torque. See \nsetGoalTorque()\n. When torque mode is enabled, you can no longer control the servo's positon.\n\n\n\n\n\n\nNotation\n\n\nDynamixel.torqueControl(ID, enable)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID : Current ID of the servomotor\n\n\n\n\n\n\n\n\nbool enable: \nTrue\n for enabling and \nFalse\n for disabling\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nint DynamixelClass::readTorqueControl( uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nRead the Torque control mode status. RAM ADDRESS: 70(0x46)\n\n\n\n\n\n\nNotation\n\n\nstatus = Dynamixel.readTorqueControl(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID : Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\n1 if torque mode is enabled and 0 otherwise\n\n\n\n\n\n\n\n\nint DynamixelClass::setGoalTorque(uint8_t ID, int torque)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set the goal torque. RAM ADDRESS: 71(0x47) and 72(0x48). In reality you are setting a desired current and the torque will be proportional\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setGoalTorque(ID, torque)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID : Current ID of the servomotor\n\n\n\n\n\n\n\n\nint torque: [0,1023] for CCW torque and [1024,2047] for CW. The unit is 4.5 [mA]. The goal torque value cannot be bigger than the torque limit value\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nTODO: Add picture\n\n\nint DynamixelClass::setGoalAccel(uint8_t ID, uint8_t accel)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set goal acceleration/ RAM ADDRESS: 73(0x49)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setGoalAccel(ID, accel)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID : Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t accel: desired acceleration [0,254]\n\n\n\n\n\n\nReturns\n\n\nNumber representing an error (if any)\n\n\n\n\n\n\n\n\nCustom Functions\n\n\nThese functions build upon the previous ones to provide more advanced functionality.\nIn particular there are several functions in order to find your connected servo in case you don't know its ID or the baudrate it is communicating with.\nThis is very useful for debugging new code that may overwrite a register accidentaly.\nFor example, if you can' remember your servo's ID or don't know the baudrate it is using, and you do not have the USB2Dynamixel product to debug your servo, then you can use this functions to find it.\nNeedless to say, I wrote these functions because at some point I accidentally changed the servo's ID and baudrate to an unknown value and couldn't communicate with it.\nConnect only one servo to find it.\n\n\nvoid DynamixelClass::configureServo(uint8_t ID, uint8_t newID, long baud)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nConfigure both ID and Baudrate of the servo\n\n\n\n\n\n\nNotation\n\n\nDynamixel.configureServo(ID, newID, baud)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID : Current ID of the servomotor\n\n\n\n\n\n\n\n\nuint8_t newID : New ID for the servomotor\n\n\n\n\n\n\n\n\nlong baud : New baudrate for communication\n\n\n\n\n\n\nReturns\n\n\nNothing\n\n\n\n\n\n\n\n\nvoid DynamixelClass::setAngleLimit(uint8_t ID, int CWLimit, int CCWLimit)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nSet both angle limits\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setAngleLimit(ID, CWLimit, CCWLimit )\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID : Current ID of the servomotor\n\n\n\n\n\n\n\n\nint CWLimit: Clockwise limit for the servo\n\n\n\n\n\n\n\n\nint CCWLimit: Counter-clockwise limit for the servo\n\n\n\n\n\n\nReturns\n\n\nNothing\n\n\n\n\n\n\n\n\nvoid DynamixelClass::setWheelMode(uint8_t ID, bool enable)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set both limits to 0. The servo is functioning in wheel mode\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setWheelMode(ID, enable)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\n\n\nbool enable: Enables or disables servo's wheel mode. If disabled, the servo defaults to the usual [0,4095] range of motion\n\n\n\n\n\n\nReturns\n\n\nNothing\n\n\n\n\n\n\n\n\nvoid DynamixelClass::setJointMode(uint8_t ID)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set the servo as joint mode. Equivalent to setWheelMode(ID, false)\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setJointMode(ID)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID: Current ID of the servomotor\n\n\n\n\n\n\nReturns\n\n\nNothing\n\n\n\n\n\n\n\n\nvoid DynamixelClass::setDIP(uint8_t ID, int gainD, int gainI, int gainP)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to set all gains. Be careful with the order\n\n\n\n\n\n\nNotation\n\n\nDynamixel.setDIP(ID, gainD, gainI, gainP)\n\n\n\n\n\n\nParameters\n\n\nuint8_t ID : Current ID of the servomotor\n\n\n\n\n\n\n\n\nint gainD: Derivative gain\n\n\n\n\n\n\n\n\nint gainI: Integral gain\n\n\n\n\n\n\n\n\nint gainP: Proportional gain\n\n\n\n\n\n\nReturns\n\n\nNothing\n\n\n\n\n\n\n\n\nint DynamixelClass::findByBaudRate(long baudRate)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to find the ID of the servo, if you have the correct baudrate. Assume begin() has been called\n\n\n\n\n\n\nNotation\n\n\nfoundID = Dynamixel.findByBaudRate(baudRate)\n\n\n\n\n\n\nParameters\n\n\nlong baudRate: baudrate used for communication\n\n\n\n\n\n\nReturns\n\n\nFound ID of the servo. If no servo is found (meaning you have the incorrect baudrate) then the value returned is -1\n\n\n\n\n\n\n\n\nint DynamixelClass::findByID(uint8_t id, uint8_t directionPin)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFunction to find the baudrate to communicate with the servo, if you have the correct ID. Assume begin() has NOT been called\n\n\n\n\n\n\nNotation\n\n\nDynamixel.findByID(id, directionPin)\n\n\n\n\n\n\nParameters\n\n\nuint8_t id: Current id of the servomotor. This function assumes the ID is correct and you are only trying to find the correct baudrate\n\n\n\n\n\n\n\n\nuint8_t directionPin: The pin used for data flow control.\n\n\n\n\n\n\nReturns\n\n\nThe baudrate (table value [0,255]) representing the baudrate. Returns -1 if the servo was not found\n\n\n\n\n\n\n\n\nvoid DynamixelClass::findServo(uint8_t directionPin)\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nFind the servo without having any information. Assume begin() has NOT been called. The function doesn't return anything but prints the result to the terminal (Use the Arduino IDE built in terminal monitor). This is the last resort to find your servo info. Since it tries all baudrates and IDs, it may take a while\n\n\n\n\n\n\nNotation\n\n\nDynamixel.findServo(directionPin)\n\n\n\n\n\n\nParameters\n\n\nuint8_t directionPin: Pin used for flow control\n\n\n\n\n\n\nReturns\n\n\nNothing. Check the output in the terminal\n\n\n\n\n\n\n\n\nvoid DynamixelClass::changeTimeOut(uint8_t newTimeOut)\n\n\nIntroduced in \nDuoDMXL\n v.0.3.\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nChange time out period (waiting time for status package). Unit is [ms]. The maximum value is 255. The default value is 50[ms]\n\n\n\n\n\n\nNotation\n\n\nDynamixel.changeTimeOut(newTimeOut)\n\n\n\n\n\n\nParameters\n\n\nuint8_t newTimeOut: New time out period\n\n\n\n\n\n\nReturns\n\n\nNothing\n\n\n\n\n\n\n\n\nvoid DynamixelClass::changeCoolDown(uint16_t newCoolDown)\n\n\nIntroduced in \nDuoDMXL\n v.0.3.\n\n\n\n\n\n\n\n\nInformation\n\n\n\n\n\n\n\n\n\n\n\n\nDescription\n\n\nChange cool down period (time between sending commands). Unit is [ms]. The maximum value is 65,535 (i.e., 65.535 seconds). The default value is 0[ms]\n\n\n\n\n\n\nNotation\n\n\nDynamixel.changeCoolDown(newCoolDown)\n\n\n\n\n\n\nParameters\n\n\nuint16_t newCoolDown: New cool down period\n\n\n\n\n\n\nReturns\n\n\nNothing",
            "title": "Code description"
        },
        {
            "location": "/source/source/#basic-functions",
            "text": "This set of functions are intended to work  behind the scenes .\nIn other words, the user should not have to worry about them.\nThey deal with low-level communication and are called by other functions.  int DynamixelClass::readInformation(void)     Information       Description  General function to read the status package from a servo. It then extracts the error (if any) or desired data (for example, if the current positon of a servo was requested)    Notation  Private  function. Not available to the user    Parameters  None    Returns  A number representing an error or data     int DynamixelClass::sendWord(uint8_t ID, uint8_t address, int param, int noParams)     Information       Description  Function to set the value of a servo's address. noParams should be ONE_BYTE or TWO_BYTES, depending on how many bytes we need to send    Notation  Dynamixel.sendWord(ID, address, param, noParams)    Parameters  uint8_t ID: ID of the servo     uint8_t address: Address to write to.     int param: Value to write to the servo's address     int noParams: Number of bytes to write (one or two bytes)    Returns  A number representing an error (if any)     int DynamixelClass::readWord(uint8_t ID, uint8_t address, int noParams)     Information       Description  Function to read the value of a servo's address. noParams should be ONE_BYTE or TWO_BYTES, depending on how many bytes we need    Notation  Dynamixel.readWord(ID, address, noParams)    Parameters  uint8_t ID: ID of the servo     uint8_t address: Address to read from.     int noParams: Number of bytes to read (one or two bytes)    Returns  A number representing an error (if any) or the desired data     For example, to change the ID of a servo, a new ID should be written to the register's address 0x03.\nThis can be accomplished quickly and cleanly with the following code:  int DynamixelClass::setID(uint8_t ID, uint8_t newID){\n    return(sendWord(ID, EEPROM_ID, newID, ONE_BYTE));\n}  This should make it easier for the user to write custom functions. The hierarchy of the library is shown (simplified) in the following picture.",
            "title": "Basic functions"
        },
        {
            "location": "/source/source/#functions-related-to-the-eeprom-area-of-the-servos",
            "text": "void DynamixelClass::begin(long baud, uint8_t directionPin)     Information       Description  Initialize communication with the servos with a user-defined pin for the data direction control    Notation  Dynamixel.begin(baud, directionPin)    Parameters  long baud: Desired baudrate for communication with the servos. For MX-64AR the default baudrate is 1Mbps (if I remember correctly)     uint8_t directionPin: direction used for flow control.    Returns  Nothing     void DynamixelClass::begin(long baud)     Information       Description  Initialize communication with the servos with a pre-defined pin (D15) for the data direction control    Notation  Dynamixel.begin(baud)    Parameters  long baud: Desired baudrate for communication with the servos.    Returns  Nothing     void DynamixelClass::end()     Information       Description  End communication with the servos    Notation  Dynamixel.end()    Parameters  None    Returns  Nothing     int DynamixelClass::readModel(uint8_t ID)     Information       Description  Function to read the servo model. EEPROM Address 0(x00) and 1(0x01)    Notation  model = Dynamixel.readModel(ID)    Parameters  uint8_t ID: ID of the servo    Returns  ID of the servo     int DynamixelClass::readFirmware(uint8_t ID)     Information       Description  Function to read the version of the firmware. EEPROM Address 2(0x02)    Notation  fw = Dynamixel.readFirmware(ID)    Parameters  uint8_t ID: ID of the servo    Returns  Number representing the firmware version of the servo     int DynamixelClass::setID(uint8_t ID, uint8_t newID)     Information       Description  Function to set the ID of the servo. EEPROM Address 3(0x03)    Notation  Dynamixel.setID(ID, newID)    Parameters  uint8_t ID: Current ID of the servomotor     uint8_t newID: New ID of the servomotor    Returns  Number representing an error (if any)     int DynamixelClass::readID(uint8_t ID)     Information       Description  Function to read the ID of the servo. EEPROM Address 3(0x03)    Notation  id = Dynamixel.readID(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Current ID of the servo     int DynamixelClass::setBD(uint8_t ID, long baud)     Information       Description  Function to set baudrate. EEPROM Address 4(0x04)    Notation  Dynamixel.setBD(ID, baud)    Parameters  uint8_t ID: Current ID of the servomotor     long baud: Desired baudrate for communication. Up to 1Mbps (use 1000000) is officially supported by the servos. This functions truncates the number so there may be a small error on the final value.    Returns  Number representing an error (if any)     int DynamixelClass::setBDTable(uint8_t ID, uint8_t baud)     Information       Description  Function to set baudrate based on the manual's table. EEPROM Address 4(0x04). This is a more precise value. For example, for communication at 57600 bps use '34'.    Notation  Dynamixel.setBDTable(ID, baud)    Parameters  uint8_t ID: Current ID of the servomotor     uint8_t baud: Number from 0 to 255 representing a desired baudrate for communication    Returns  Number representing an error (if any)     int DynamixelClass::readBD(uint8_t ID)     Information       Description  Function to read the setting of the baudrate. EEPROM Address 4(0x04)    Notation  baudrate = Dynamixel.readBD(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Number from 0 to 255 representing the baudrate currently being used     int DynamixelClass::setRDT(uint8_t ID, uint8_t RDT)     Information       Description  Set the Return Delay Time (RDT) in microseconds. EEPROM Address 5(0x05)    Notation  Dynamixel.setRDT(ID, RDT)    Parameters  uint8_t ID: Current ID of the servomotor     uint8_t RDT: Desired RDT value    Returns  Number representing an error (if any)     int DynamixelClass::readRDT(uint8_t ID)     Information       Description  Read the Return Delay Time (RDT) value. EEPROM Address 5(0x05)    Notation  rdt = Dynamixel.readRDT(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Current value of RDT     int DynamixelClass::setCWAngleLimit(uint8_t ID, int limit)     Information       Description  Set the value for the CW Angle limit. EEPROM Address 6(0x06) and 7(0x07)    Notation  Dynamixel.setCWAngleLimit(ID, limit)    Parameters  uint8_t ID: Current ID of the servomotor     int limit: Desired limit    Returns  Number representing an error (if any)     int DynamixelClass::readCWAngleLimit(uint8_t ID)     Information       Description  Read the value for the CW Angle limit. EEPROM Address 6(0x06) and 7(0x07)    Notation  cwLimit = Dynamixel.readCWAngleLimit(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Angle being used for clockwise limit of the servo     int DynamixelClass::setCCWAngleLimit(uint8_t ID, int limit)     Information       Description  Set the value for the CCW Angle limit. EEPROM Address 8(0x08) and 9(0x09)    Notation  Dynamixel.setCCWAngleLimit(ID, limit)    Parameters  uint8_t ID: Current ID of the servomotor     int limit: Desired limit    Returns  Number representing an error (if any)     int DynamixelClass::readCCWAngleLimit(uint8_t ID)     Information       Description  Read the value for the CCW Angle limit. EEPROM Address 8(0x08) and 9(0x09)    Notation  ccwLimit = Dynamixel.readCCWAngleLimit(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Angle being used for counter-clockwise limit of the servo     int DynamixelClass::setTempLimit(uint8_t ID, uint8_t Temperature)     Information       Description  Set the limit temperature. EEPROM Address 11(0x0B)    Notation  Dynamixel.setTempLimit(ID, Temperature)    Parameters  uint8_t ID: Current ID of the servomotor     uint8_t Temperature: Temperature that will be set as limit. The servo will shutdown if this temperature is reached. Documentation suggests not modifying the default value.    Returns  Number representing an error (if any)     int DynamixelClass::readTempLimit(uint8_t ID)     Information       Description  Read the limit temperature. EEPROM Address 11(0x0B)    Notation  tempLimit = Dynamixel.readTempLimit(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Temperature used as upper limit     int DynamixelClass::setLowVoltageLimit(uint8_t ID, uint8_t lowVoltage)     Information       Description  Set the lowest voltage limit. EEPROM Address 12(0x0C)    Notation  Dynamixel.setLowVoltageLimit(ID, lowVoltage)    Parameters  uint8_t ID: Current ID of the servomotor     uint8_t lowVoltage: Lower bound for voltage limit    Returns  Number representing an error (if any)     int DynamixelClass::readLowVoltageLimit(uint8_t ID)     Information       Description  Read the lowest voltage limit. EEPROM Address 12(0x0C)    Notation  lowVoltageLimit = Dynamixel.readLowVoltageLimit(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Lower bound voltage     int DynamixelClass::setHighVoltageLimit(uint8_t ID, uint8_t highVoltage)     Information       Description  Set the highest voltage limit. EEPROM Address 13(0x0D)    Notation  Dynamixel.setHighVoltageLimit(ID, highVoltage)    Parameters  uint8_t ID: Current ID of the servomotor     uint8_t highVoltage: Upper bound for voltage limit    Returns  Number representing an error (if any)     int DynamixelClass::readHighVoltageLimit(uint8_t ID)     Information       Description  Read the highest voltage limit. EEPROM Address 13(0x0D)    Notation  highVoltageLimit = Dynamixel.readHighVoltageLimit(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Upper bound voltage     int DynamixelClass::setMaxTorque(uint8_t ID, int MaxTorque)     Information       Description  Set the maximum torque. EEPROM Address 14(0x0E) and 15(0x0F)    Notation  Dynamixel.setMaxTorque(ID, MaxTorque)    Parameters  uint8_t ID: Current ID of the servomotor     int MaxTorque: Value from [0, 1023] used for maximum output torque.    Returns  Number representing an error (if any)     int DynamixelClass::readMaxTorque(uint8_t ID)     Information       Description  Read the maximum torque. EEPROM Address 14(0x0E) and 15(0x0F)    Notation  maxTorque = Dynamixel.readMaxTorque(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Value from [0, 1023] representing the maximum output torque currently used.     int DynamixelClass::setSRL(uint8_t ID, uint8_t SRL)  Improved functionality in  DuoDMXL  v.0.3.     Information       Description  Set the Status Return Level. EEPROM Address 16(0x10)    Notation  Dynamixel.setSRL(ID, SRL)    Parameters  uint8_t ID: Current ID of the servomotor     uint8_t SRL: 0, 1, or 2 for 'no return against all commands', 'return only for the READ command', or 'Return for all commands', respectively.    Returns  Number representing an error (if any)     As of  DuoDMXL  v.0.3 the user can choose any SRL.\nHowever,  DuoDMXL  assumes on reset that all servos have the same SRL and ALL communications return a package (i.e.,  SRL=2 ).\nIf you changed the value of SRL on a previous session, there may be problems with the communication, since the value of SRL is written in the EEPROM memory of the servos.\nIf you are having troubles with communication use:      Dynamixel.begin(baud, dataPin);\n    delay(500);\n    Dynamixel.setSRL(254, 2);  at the beginning of your program to set all servos to 'Return for all commands'.  NOTE :  254  is the broadcast ID. Any command is sent to all servos.  int DynamixelClass::readSRL(uint8_t ID)     Information       Description  Read the Status Return Level value. EEPROM Address 16(0x10)    Notation  srl = Dynamixek.readSRL(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Actual value of the SRL address     int DynamixelClass::setAlarmLED(uint8_t ID, uint8_t alarm)     Information       Description  Set Alarm LED. EEPROM Address 17(0x11)    Notation  Dynamixel.setAlarmLED(ID, alarm)    Parameters  uint8_t ID: Current ID of the servomotor     uint8_t alarm: The servo's LED will blink if an error occurs    Returns  Number representing an error (if any)     int DynamixelClass::readAlarmLED(uint8_t ID)     Information       Description  Read Alarm LED value. EEPROM Address 17(0x11)    Notation  alarm = Dynamixel.readAlarmLED(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Actual value of the alarm address     int DynamixelClass::setShutdownAlarm(uint8_t ID, uint8_t SALARM)     Information       Description  Set Shutdown alarm. EEPROM Address 18(0x12)    Notation  Dynamixel.setShutdownAlarm(ID, SALARM)    Parameters  uint8_t ID: Current ID of the servomotor     uint8_t SALARM: Check the documentation. Depending on the value sent, the servo will output a 0% torque if an alarm is activated. By default the value is 36 (0x24) which in binary is '0010 0100', meaning overload+overheating error.    Returns  Number representing an error (if any)      int DynamixelClass::readShutdownAlarm(uint8_t ID)     Information       Description  Read Shutdown alarm value. EEPROM Address 18(0x12)    Notation  alarm = Dynamixel.readShutdownAlarm(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Read the value of the alarm address to verify if an alarm was activated     int DynamixelClass::setMultiTurnOffset(uint8_t ID, int offset)     Information       Description  Set the multi-turn offset values. EEPROM ADDRESS: 20(0x14) and 21(0x15)    Notation  Dynamixel.setMultiTurnOffset(ID, offset)    Parameters  uint8_t ID: Current ID of the servomotor     int offset: Angle used for servo's offset in multi-turn mode    Returns  Number representing an error (if any)     int DynamixelClass::readMultiTurnOffset(uint8_t ID)     Information       Description  Read the multi-turn offset values. EEPROM ADDRESS: 20(0x14) and 21(0x15)    Notation  offset = Dynamixel.readMultiTurnOffset(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Read the actual offset being used for multi-turn mode     int DynamixelClass::setResolutionDivider(uint8_t ID, uint8_t divider)     Information       Description  Set the resolution divider value. EEPROM ADDRESS: 22(0x16)    Notation  Dynamixel.setResolutionDivider(ID, divider)    Parameters  uint8_t ID: Current ID of the servomotor     uint8_t divider: Divider for the servo's angle. By default divider=1    Returns  Number representing an error (if any)     int DynamixelClass::readResolutionDivider(uint8_t ID)     Information       Description  Read the resolution divider value. EEPROM ADDRESS: 22(0x16)    Notation  divider = Dynamixel.readResolutionDivider(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Actual value used for the servo's divider",
            "title": "Functions related to the EEPROM area of the servos"
        },
        {
            "location": "/source/source/#functions-related-to-the-ram-area-of-the-servos",
            "text": "int DynamixelClass::torqueEnable( uint8_t ID, bool Status)     Information       Description  Function to turn ON or OFF torque. RAM Address 24(0x18)    Notation  Dynamixel.torqueEnable(ID, Status)    Parameters  uint8_t ID: Current ID of the servomotor     bool Status: True or False for enabling or disabling torque, respectively.    Returns  Number representing an error (if any)     int DynamixelClass::torqueEnableStatus( uint8_t ID)     Information       Description  Function to check if the servo generates torque. RAM Address 24(0x18)    Notation  status = Dynamixel.torqueEnableStatus(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  1 if torque is enabled. 0 if disabled     int DynamixelClass::ledStatus(uint8_t ID, bool Status)     Information       Description  Function to turn ON or OFF the servo's LED. RAM Address 25(0x19)    Notation  Dynamixel.ledStatus(ID, Status)    Parameters  uint8_t ID: Current ID of the servomotor     bool Status: True or False for enabling or disabling the LED, respectively. I do not provide a function to read this register, so  visual confirmation  should be used.    Returns  Number representing an error (if any)     int DynamixelClass::setGainD(uint8_t ID, int gain)     Information       Description  Function to set the value of the Derivative gain. RAM Address 26(0x1A)    Notation  Dynamixel.setGainD(ID, gain)    Parameters  uint8_t ID: Current ID of the servomotor     int gain: Number [0,254] used for the Derivative gain of the servo. Related to the servo's PID control    Returns  Number representing an error (if any)     int DynamixelClass::readGainD(uint8_t ID)     Information       Description  Function to read the value of the Derivative gain. RAM Address 26(0x1A)    Notation  gainD = Dynamixel.readGainD(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Derivative gain     int DynamixelClass::setGainI(uint8_t ID, int gain)     Information       Description  Function to set the value of the Integral gain. RAM Address 27(0x1B)    Notation  Dynamixel.setGainI(ID, gain)    Parameters  uint8_t ID: Current ID of the servomotor     int gain: Number [0,254] used for the Integral gain of the servo. Related to the servo's PID control    Returns  Number representing an error (if any)     int DynamixelClass::readGainI(uint8_t ID)     Information       Description  Function to read the value of the Integral gain. RAM Address 27(0x1B)    Notation  gainI = Dynamixel.readGainI(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Integral gain     int DynamixelClass::setGainP(uint8_t ID, int gain)     Information       Description  Function to set the value of the Proportional gain. RAM Address 28(0x1C)    Notation  Dynamixel.setGainP(ID, gain)    Parameters  uint8_t ID: Current ID of the servomotor     int gain: Number [0,254] used for the Proportional gain of the servo. Related to the servo's PID control    Returns  Number representing an error (if any)     int DynamixelClass::readGainP(uint8_t ID)     Information       Description  Function to read the value of the Proportional gain. RAM Address 28(0x1C)    Notation  gainP = Dynamixel.readGainP(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Proportional gain     int DynamixelClass::move(uint8_t ID, int Position)     Information       Description  Function to move servo to a specific position. RAM Address 30(0x1E) and 31(0x1F)    Notation  Dynamixel.move(ID, Position)    Parameters  uint8_t ID: Current ID of the servomotor     int Position: Number [0,4095] representing the desired position. The unit is about 0.088 degrees    Returns  Number representing an error (if any)     int DynamixelClass::setMovingSpeed(uint8_t ID, int speed)     Information       Description  Function to set the desired moving speed. RAM Address 32(0x20) and 33(0x21)    Notation  Dynamixel.setMovingSpeed(ID, speed)    Parameters  uint8_t ID: Current ID of the servomotor     int speed: Number [0,1023] representing moving speed. The unit is about 0.114 rpm.    Returns  Number representing an error (if any)     int DynamixelClass::readMovingSpeed(uint8_t ID)     Information       Description  Function to read the desired moving speed. RAM Address 32(0x20) and 33(0x21)    Notation  speed = Dynamixel.readMovingSpeed(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Moving speed value in the register     int DynamixelClass::setTorqueLimit(uint8_t ID, int torque)     Information       Description  Function to set the value of the goal torque. RAM Address 34(0x22) and 35(0x23)    Notation  Dynamixel.setTorqueLimit(ID, torque)    Parameters  uint8_t ID: Current ID of the servomotor     int torque: Number [0,1023] used for torque limit. The servo will not exert a higher torque. According to documentation, if the motor is disabled due to activating an alarm, this register will be set to 0. To re-enable the servo set a non-zero value. When the motor is turned on, the torque limit will take the value currently written in the EEPROM address 0x0E. Check the function  setMaxTorque()  if you want to change this value.    Returns  Number representing an error (if any)     int DynamixelClass::readTorqueLimit(uint8_t ID)     Information       Description  Function to read the value of the goal torque. RAM Address 34(0x22) and 35(0x23)    Notation  torqueLimit = readTorqueLimit(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Torque limit value [0,1023]     int DynamixelClass::readPosition(uint8_t ID)     Information       Description  Read the actual position. RAM Address 36(0x24) and 37(0x25)    Notation  pos = Dynamixel.readPosition(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  The actual position of the servo     int DynamixelClass::readSpeed(uint8_t ID)     Information       Description  Read the actual speed. RAM Address 38(0x26) and 39(0x27)    Notation  speed = Dynamixel.readSpeed(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  The actual speed of the servo (possible values [0,2047]). [0,1023] correspond to CCW and [1024,2047] to CW speeds, respectively. In other words, the magnitude is given by the first nine bits [0,1023] and the tenth bit denotes the direction.      int DynamixelClass::readLoad(uint8_t ID)     Information       Description  Read the load. RAM Address 40(0x28) and 41(0x29)    Notation  load = Dynamixel.readLoad(ID)    Parameters  uint8_t ID: Current ID of the servomotor     Reads the currently applied load. However, according to documentation, this value is inferred from the internal torque value and should not be used for accurate torque measurement. It is better to read the current.    Returns  The currently applied load. If the load is CCW the value will be [0,1023] and of CW then [1024,2047]     int DynamixelClass::readVoltage(uint8_t ID)     Information       Description  Function to read the voltage. RAM Address 42(0x2A)    Notation  voltage = Dynamixel.readVoltage(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  (10 times) The actual voltage     int DynamixelClass::readTemperature(uint8_t ID)     Information       Description  Function to read the Temperature. RAM Address 43(0x2B)    Notation  temp = Dynamixel.readTemperature(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Actual temperature of the servo (Celsius degrees)     int DynamixelClass::registeredStatus(uint8_t ID)     Information       Description  Check if there is an instruction registered. RAM Address 44(0x2C)    Notation  status = Dyunamixel.registeredStatus(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  0 if there are no commands registered, and 1 otherwise     int DynamixelClass::moving(uint8_t ID)     Information       Description  Check if goal position command is being executed (Address 0x30?). RAM Address 46(0x2E)    Notation  moving = Dynamixel.moving(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  0 if the servo is not moving and 1 if otherwise     int DynamixelClass::lockEEPROM(uint8_t ID)     Information       Description  Locks the EEPROM area. RAM Address 47(0x2F). Power must be turned off to reset it    Notation  Dynamixel.lockEEPROM(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Number representing an error (if any)     int DynamixelClass::setPunch(uint8_t ID, int Punch)     Information       Description  RAM Address 48(0x30) and 49(0x31). Honestly, I do not understand this feature even after reading the documentation    Notation  Dynamixel.setPunch(ID, Punch)    Parameters  uint8_t ID: Current ID of the servomotor     int Punch: number [0,1023]    Returns  Number representing an error (if any)     int DynamixelClass::readPunch(uint8_t ID)     Information       Description  Reads the value of RAM Address 48(0x30) and 49(0x31). See the note in  setPunch()    Notation  punch = Dynamixel.readPunch(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  punch     int DynamixelClass::readCurrent(uint8_t ID)     Information       Description  Function to read the current. RAM ADDRESS: 68(0x44) and 69(0x45)    Notation  current = Dynamixel.readCurrent(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Actual current running through the servo     TODO: Add picture  int DynamixelClass::torqueControl( uint8_t ID, bool enable)     Information       Description  Torque control mode enable. RAM ADDRESS: 70(0x46). The servo can run continuously trying to achieve the desired (goal) torque. See  setGoalTorque() . When torque mode is enabled, you can no longer control the servo's positon.    Notation  Dynamixel.torqueControl(ID, enable)    Parameters  uint8_t ID : Current ID of the servomotor     bool enable:  True  for enabling and  False  for disabling    Returns  Number representing an error (if any)     int DynamixelClass::readTorqueControl( uint8_t ID)     Information       Description  Read the Torque control mode status. RAM ADDRESS: 70(0x46)    Notation  status = Dynamixel.readTorqueControl(ID)    Parameters  uint8_t ID : Current ID of the servomotor    Returns  1 if torque mode is enabled and 0 otherwise     int DynamixelClass::setGoalTorque(uint8_t ID, int torque)     Information       Description  Function to set the goal torque. RAM ADDRESS: 71(0x47) and 72(0x48). In reality you are setting a desired current and the torque will be proportional    Notation  Dynamixel.setGoalTorque(ID, torque)    Parameters  uint8_t ID : Current ID of the servomotor     int torque: [0,1023] for CCW torque and [1024,2047] for CW. The unit is 4.5 [mA]. The goal torque value cannot be bigger than the torque limit value    Returns  Number representing an error (if any)     TODO: Add picture  int DynamixelClass::setGoalAccel(uint8_t ID, uint8_t accel)     Information       Description  Function to set goal acceleration/ RAM ADDRESS: 73(0x49)    Notation  Dynamixel.setGoalAccel(ID, accel)    Parameters  uint8_t ID : Current ID of the servomotor     uint8_t accel: desired acceleration [0,254]    Returns  Number representing an error (if any)",
            "title": "Functions related to the RAM area of the servos"
        },
        {
            "location": "/source/source/#custom-functions",
            "text": "These functions build upon the previous ones to provide more advanced functionality.\nIn particular there are several functions in order to find your connected servo in case you don't know its ID or the baudrate it is communicating with.\nThis is very useful for debugging new code that may overwrite a register accidentaly.\nFor example, if you can' remember your servo's ID or don't know the baudrate it is using, and you do not have the USB2Dynamixel product to debug your servo, then you can use this functions to find it.\nNeedless to say, I wrote these functions because at some point I accidentally changed the servo's ID and baudrate to an unknown value and couldn't communicate with it.\nConnect only one servo to find it.  void DynamixelClass::configureServo(uint8_t ID, uint8_t newID, long baud)     Information       Description  Configure both ID and Baudrate of the servo    Notation  Dynamixel.configureServo(ID, newID, baud)    Parameters  uint8_t ID : Current ID of the servomotor     uint8_t newID : New ID for the servomotor     long baud : New baudrate for communication    Returns  Nothing     void DynamixelClass::setAngleLimit(uint8_t ID, int CWLimit, int CCWLimit)     Information       Description  Set both angle limits    Notation  Dynamixel.setAngleLimit(ID, CWLimit, CCWLimit )    Parameters  uint8_t ID : Current ID of the servomotor     int CWLimit: Clockwise limit for the servo     int CCWLimit: Counter-clockwise limit for the servo    Returns  Nothing     void DynamixelClass::setWheelMode(uint8_t ID, bool enable)     Information       Description  Function to set both limits to 0. The servo is functioning in wheel mode    Notation  Dynamixel.setWheelMode(ID, enable)    Parameters  uint8_t ID: Current ID of the servomotor     bool enable: Enables or disables servo's wheel mode. If disabled, the servo defaults to the usual [0,4095] range of motion    Returns  Nothing     void DynamixelClass::setJointMode(uint8_t ID)     Information       Description  Function to set the servo as joint mode. Equivalent to setWheelMode(ID, false)    Notation  Dynamixel.setJointMode(ID)    Parameters  uint8_t ID: Current ID of the servomotor    Returns  Nothing     void DynamixelClass::setDIP(uint8_t ID, int gainD, int gainI, int gainP)     Information       Description  Function to set all gains. Be careful with the order    Notation  Dynamixel.setDIP(ID, gainD, gainI, gainP)    Parameters  uint8_t ID : Current ID of the servomotor     int gainD: Derivative gain     int gainI: Integral gain     int gainP: Proportional gain    Returns  Nothing     int DynamixelClass::findByBaudRate(long baudRate)     Information       Description  Function to find the ID of the servo, if you have the correct baudrate. Assume begin() has been called    Notation  foundID = Dynamixel.findByBaudRate(baudRate)    Parameters  long baudRate: baudrate used for communication    Returns  Found ID of the servo. If no servo is found (meaning you have the incorrect baudrate) then the value returned is -1     int DynamixelClass::findByID(uint8_t id, uint8_t directionPin)     Information       Description  Function to find the baudrate to communicate with the servo, if you have the correct ID. Assume begin() has NOT been called    Notation  Dynamixel.findByID(id, directionPin)    Parameters  uint8_t id: Current id of the servomotor. This function assumes the ID is correct and you are only trying to find the correct baudrate     uint8_t directionPin: The pin used for data flow control.    Returns  The baudrate (table value [0,255]) representing the baudrate. Returns -1 if the servo was not found     void DynamixelClass::findServo(uint8_t directionPin)     Information       Description  Find the servo without having any information. Assume begin() has NOT been called. The function doesn't return anything but prints the result to the terminal (Use the Arduino IDE built in terminal monitor). This is the last resort to find your servo info. Since it tries all baudrates and IDs, it may take a while    Notation  Dynamixel.findServo(directionPin)    Parameters  uint8_t directionPin: Pin used for flow control    Returns  Nothing. Check the output in the terminal     void DynamixelClass::changeTimeOut(uint8_t newTimeOut)  Introduced in  DuoDMXL  v.0.3.     Information       Description  Change time out period (waiting time for status package). Unit is [ms]. The maximum value is 255. The default value is 50[ms]    Notation  Dynamixel.changeTimeOut(newTimeOut)    Parameters  uint8_t newTimeOut: New time out period    Returns  Nothing     void DynamixelClass::changeCoolDown(uint16_t newCoolDown)  Introduced in  DuoDMXL  v.0.3.     Information       Description  Change cool down period (time between sending commands). Unit is [ms]. The maximum value is 65,535 (i.e., 65.535 seconds). The default value is 0[ms]    Notation  Dynamixel.changeCoolDown(newCoolDown)    Parameters  uint16_t newCoolDown: New cool down period    Returns  Nothing",
            "title": "Custom Functions"
        },
        {
            "location": "/hardware/Duo_TristateBuffer_shield/",
            "text": "Duo Tri-state Buffer Shield\n\n\nThe \nTri-state Buffer Shield\n takes the TX and RX signals from the DUO, and with an additional pin for flow control, interfaces with the DYNAMIXEL servo with one line of data (half-duplex).\n\n\n\n\nThe shield includes an additional voltage boost converter \nMAX1674\n to output 5V and drive the buffer \nSN74LS241\n. The eagle schematic and board layout can be found in the repository. I add an additional jumper \nJ1\n to control the Vcc voltage used for driving the servo. For example, if using external power (e.g., using an SMPS2Dynamixel) then the jumper must be OFF. I highly recommend to use external power, but if you need basic tests and use only small servos, maybe (MAYBE) using 5V from the board itself would be safe.\n\n\n\n\nHere is a render done with \necad.io\n.\nSome of the components are slightly different from the real ones because I could not find the correct packages.\n\n\n\nAnd this is the final board.\nThe PCB was manufactured using \nELECROW\n's service and the components were soldered by myself.\n\n\n\n\n\n\nDisclaimer\n\n\nThis shield has not been fully tested and I am not responsible for any malfunction or damage to your equipment. Source code and schematics are provided as-is. I \nstrongly\n suggest you to take a good look at them before testing the board.",
            "title": "Duo Tri-state Buffer Shield"
        },
        {
            "location": "/hardware/Duo_TristateBuffer_shield/#duo-tri-state-buffer-shield",
            "text": "The  Tri-state Buffer Shield  takes the TX and RX signals from the DUO, and with an additional pin for flow control, interfaces with the DYNAMIXEL servo with one line of data (half-duplex).   The shield includes an additional voltage boost converter  MAX1674  to output 5V and drive the buffer  SN74LS241 . The eagle schematic and board layout can be found in the repository. I add an additional jumper  J1  to control the Vcc voltage used for driving the servo. For example, if using external power (e.g., using an SMPS2Dynamixel) then the jumper must be OFF. I highly recommend to use external power, but if you need basic tests and use only small servos, maybe (MAYBE) using 5V from the board itself would be safe.   Here is a render done with  ecad.io .\nSome of the components are slightly different from the real ones because I could not find the correct packages.  And this is the final board.\nThe PCB was manufactured using  ELECROW 's service and the components were soldered by myself.",
            "title": "Duo Tri-state Buffer Shield"
        },
        {
            "location": "/hardware/Duo_TristateBuffer_shield/#disclaimer",
            "text": "This shield has not been fully tested and I am not responsible for any malfunction or damage to your equipment. Source code and schematics are provided as-is. I  strongly  suggest you to take a good look at them before testing the board.",
            "title": "Disclaimer"
        },
        {
            "location": "/hardware/Duo_Rs485_shield/",
            "text": "Duo RS-485 Shield\n\n\nThe \nRS-485 Shield\n takes the TX and RX signals from the DUO, and with an additional pin for flow control, interfaces with the DYNAMIXEL servo with two lines of data. The RS-485 protocol is a differential type of communication so it is better suited for communication through longer distances.\n\n\n\n\nThe shield requires little extra hardware, since the transceiver can be chosen for 3.3V microcontrollers. This version of the shield uses \nST4485EB\n RS-485 transceiver. It can communicate up to 20Mbps, however, the DYNAMIXEL servos can communicate at a maximum baudrate of 1Mbps, so there should be no problem.\nHere is a render done with \necad.io\n:\n\n\n\nAn additional complexity when using a RS-485 bus, is the addition of a termination resistor. This is a cumbersome topic and after several hours of research have not come up with the optimal solution. Most of the references I have found are anecdotical and sometimes a little contradictory. A good reference is the \nGuidelines for Proper Wiring of an RS-485 (TIA/EIA-485-A) Network\n published by Maxim Integrated. An additional problem is that I am not sure how the servos are connected internally so I cannot draw conclusions on the topology. For example, is the microcontoller a stub, or an end in the connection? In theory, stubs should not have terminator resistors. Also, twisted wires should be use to cancel noise, but ROBOTIS official cables are not twisted.\n\n\n\n\nBefore designing the PCB, I prototyped with a breakout of a RS-485 transceiver \nRS485 SP3485 Module Board SP3485/RS485 To TTL Transceiver Converter Evaluation Development Board Kit 3.3V\n. In my (limited) experience, if you are only using one servo it work better if the transmiter end (i.e., the microcontoller) has no termination resistor. For maximum flexibility I have added a jumper \nJP1\n in the board to be able to add or remove a terminator resistor. As far as I know, this is the best way to handle the problem.\n\n\nThese are early prototypes using the \nRS485 SP3485 Module Board SP3485/RS485 To TTL Transceiver Converter Evaluation Development Board Kit 3.3V\n board as RS-485 Transceiver.\n\n\n\n\n\nAnd...this is the final board.\nThe PCB was manufactured using \nELECROW\n's service and the components were soldered by myself.\n\n\n\n\n\n\n\nDisclaimer\n\n\nThis shield has not been fully tested and I am not responsible for any malfunction or damage to your equipment. Source code and schematics are provided as-is. I \nstrongly\n suggest you to take a good look at them before testing the board.",
            "title": "Duo RS-485 Shield"
        },
        {
            "location": "/hardware/Duo_Rs485_shield/#duo-rs-485-shield",
            "text": "The  RS-485 Shield  takes the TX and RX signals from the DUO, and with an additional pin for flow control, interfaces with the DYNAMIXEL servo with two lines of data. The RS-485 protocol is a differential type of communication so it is better suited for communication through longer distances.   The shield requires little extra hardware, since the transceiver can be chosen for 3.3V microcontrollers. This version of the shield uses  ST4485EB  RS-485 transceiver. It can communicate up to 20Mbps, however, the DYNAMIXEL servos can communicate at a maximum baudrate of 1Mbps, so there should be no problem.\nHere is a render done with  ecad.io :  An additional complexity when using a RS-485 bus, is the addition of a termination resistor. This is a cumbersome topic and after several hours of research have not come up with the optimal solution. Most of the references I have found are anecdotical and sometimes a little contradictory. A good reference is the  Guidelines for Proper Wiring of an RS-485 (TIA/EIA-485-A) Network  published by Maxim Integrated. An additional problem is that I am not sure how the servos are connected internally so I cannot draw conclusions on the topology. For example, is the microcontoller a stub, or an end in the connection? In theory, stubs should not have terminator resistors. Also, twisted wires should be use to cancel noise, but ROBOTIS official cables are not twisted.   Before designing the PCB, I prototyped with a breakout of a RS-485 transceiver  RS485 SP3485 Module Board SP3485/RS485 To TTL Transceiver Converter Evaluation Development Board Kit 3.3V . In my (limited) experience, if you are only using one servo it work better if the transmiter end (i.e., the microcontoller) has no termination resistor. For maximum flexibility I have added a jumper  JP1  in the board to be able to add or remove a terminator resistor. As far as I know, this is the best way to handle the problem.  These are early prototypes using the  RS485 SP3485 Module Board SP3485/RS485 To TTL Transceiver Converter Evaluation Development Board Kit 3.3V  board as RS-485 Transceiver.   And...this is the final board.\nThe PCB was manufactured using  ELECROW 's service and the components were soldered by myself.",
            "title": "Duo RS-485 Shield"
        },
        {
            "location": "/hardware/Duo_Rs485_shield/#disclaimer",
            "text": "This shield has not been fully tested and I am not responsible for any malfunction or damage to your equipment. Source code and schematics are provided as-is. I  strongly  suggest you to take a good look at them before testing the board.",
            "title": "Disclaimer"
        },
        {
            "location": "/examples/example0/",
            "text": "Example 0 - Setting the ID of your servo\n\n\nIn this example, a servo with \nID = 1\n will be change to \n2\n. You will need to do this often with your servos since all come with the default ID of \n1\n.\nMake sure only one servo is connected to the bus.\n\n\n/*\n * Copyright (c) 2016 Fabian Eugenio Reyes Pinner (Fabian Reyes)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n /*\n  * In this example, we will change the ID of the servo from '1' to '2'. Be sure that only one servo is connected.\n  */\n\nSYSTEM_MODE(MANUAL);  //do not connect to the cloud. Communicate with the servo immediately\n\n//The DuoDMXL library allows communication with the servo\n#include <DuoDMXL.h>\n\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closes to the TX and RX pins\nint servoID = 1;\nint newID = 2;\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid setup() {\n\n  Serial.begin(115200);               //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);     // Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n\n  delay(1000);                        //Let's wait a little bit\n\n  Dynamixel.setID(servoID, newID);\n\n}\n\nvoid loop() {\n  //Do whatever you want with the servo now. Remember the servo has the new ID\n\n  Dynamixel.move(newID, 0);\n\n  delay(1000);\n\n  Dynamixel.move(newID, 4095);\n\n  delay(1000);\n}",
            "title": "Example 0"
        },
        {
            "location": "/examples/example0/#example-0-setting-the-id-of-your-servo",
            "text": "In this example, a servo with  ID = 1  will be change to  2 . You will need to do this often with your servos since all come with the default ID of  1 .\nMake sure only one servo is connected to the bus.  /*\n * Copyright (c) 2016 Fabian Eugenio Reyes Pinner (Fabian Reyes)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n /*\n  * In this example, we will change the ID of the servo from '1' to '2'. Be sure that only one servo is connected.\n  */\n\nSYSTEM_MODE(MANUAL);  //do not connect to the cloud. Communicate with the servo immediately\n\n//The DuoDMXL library allows communication with the servo\n#include <DuoDMXL.h>\n\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closes to the TX and RX pins\nint servoID = 1;\nint newID = 2;\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid setup() {\n\n  Serial.begin(115200);               //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);     // Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n\n  delay(1000);                        //Let's wait a little bit\n\n  Dynamixel.setID(servoID, newID);\n\n}\n\nvoid loop() {\n  //Do whatever you want with the servo now. Remember the servo has the new ID\n\n  Dynamixel.move(newID, 0);\n\n  delay(1000);\n\n  Dynamixel.move(newID, 4095);\n\n  delay(1000);\n}",
            "title": "Example 0 - Setting the ID of your servo"
        },
        {
            "location": "/examples/example1/",
            "text": "Example 1 - Reading the information of your servo\n\n\nIn this example, general information about the servo (e.g., ID, model, values of several memory registers) is obtained and then displayed on the output of the terminal.\n\n\n/*\n * Copyright (c) 2016 Fabian Eugenio Reyes Pinner (Fabian Reyes)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n /*\n  * In this example, the information (for example, configured values in its EEPROM or RAM area) of a servo will be obtained and displayed into the terminal.\n  * It is assumed that the ID of the servo is '1' and the baudrate configured is '57600'. This may be different of your setup, so just change the necessary\n  * parameters.\n  */\n\nSYSTEM_MODE(MANUAL);  //do not connect to the cloud. Communicate with the servo immediately\n\n//The DuoDMXL library allows communication with the servo\n#include <DuoDMXL.h>\n\nint led1 = D7;      //onboard LED\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closes to the TX and RX pins\nint servoID = 1;\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid servoIntroduction(unsigned char servoID);  //custom function\n\nvoid setup() {\n  pinMode(led1, OUTPUT);              //prepare the on-board LED\n\n  Serial.begin(115200);               //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);     // Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n\n  delay(1000);                        //Let's wait a little bit\n\n}\n\nvoid loop() {\n\n    digitalWrite(led1, HIGH);               //turn on on-board LED to show that the self-introduction has started\n\n    servoIntroduction(servoID);             //print the information of the servo with ID = servoID\n\n    digitalWrite(led1, LOW);\n\n    delay(1000);                            //wait one second and show the information again\n}\n\n//Basic information about the servo\nvoid servoIntroduction(uint8_t servoID){\n  Serial.println(\"------------------------------------------\");\n\n  Serial.print(\"Hi, I am a servo model \");\n  Serial.print(Dynamixel.readModel(servoID));\n  Serial.print(\" with Firmware version \");\n  Serial.print(Dynamixel.readFirmware(servoID));\n  Serial.print(\", my ID is \");\n  Serial.print(Dynamixel.readID(servoID));\n  Serial.print(\", communicating at a baudrate of \");\n  Serial.print(Dynamixel.readBD(servoID));\n  Serial.print(\", with a RDT of \");\n  Serial.println(Dynamixel.readRDT(servoID));\n\n  Serial.print(\"CW limit set as \");\n  Serial.print(Dynamixel.readCWAngleLimit(servoID));\n  Serial.print(\", CCW limit set as \");\n  Serial.println(Dynamixel.readCCWAngleLimit(servoID));\n\n  Serial.print(\"The temperature limit, lowest voltage limit, highest voltage limit, and max torque are: \");\n  Serial.print(Dynamixel.readTempLimit(servoID));\n  Serial.print(\", \");\n  Serial.print(Dynamixel.readLowVoltageLimit(servoID));\n  Serial.print(\", \");\n  Serial.print(Dynamixel.readHighVoltageLimit(servoID));\n  Serial.print(\", \");\n  Serial.println(Dynamixel.readMaxTorque(servoID));\n\n  Serial.print(\"My Status return level, Alarm LED, and shutdown alarm settings are: \");\n  Serial.print(Dynamixel.readSRL(servoID));\n  Serial.print(\", \");\n  Serial.print(Dynamixel.readAlarmLED(servoID));\n  Serial.print(\", \");\n  Serial.println(Dynamixel.readShutdownAlarm(servoID));\n\n  Serial.print(\"The multi-turn offset setting and resolution divider are: \");\n  Serial.print(Dynamixel.readMultiTurnOffset(servoID));\n  Serial.print(\", \");\n  Serial.println(Dynamixel.readResolutionDivider(servoID));\n\n  Serial.print(\"The DIP gains are: \");\n  Serial.print(Dynamixel.readGainD(servoID));\n  Serial.print(\", \");\n  Serial.print(Dynamixel.readGainI(servoID));\n  Serial.print(\", and \");\n  Serial.println(Dynamixel.readGainP(servoID));\n\n  Serial.print(\"The value of moving speed is: \");\n  Serial.println(Dynamixel.readMovingSpeed(servoID));\n  Serial.print(\"The value of torque limit (goal torque) is: \");\n  Serial.println(Dynamixel.readTorqueLimit(servoID));\n\n  Serial.print(\"My present load is: \");\n  Serial.println(Dynamixel.readLoad(servoID));\n  Serial.print(\"I am operating at a voltage of \");\n  Serial.print(Dynamixel.readVoltage(servoID));\n  Serial.print(\" and a temperature of \");\n  Serial.println(Dynamixel.readTemperature(servoID));\n\n  Serial.print(\"Is there a function waiting to be executed in Registered?: \");\n  Serial.println(Dynamixel.registeredStatus(servoID));\n\n  Serial.print(\"Is a moving (goal_position) command being executed?: \");\n  Serial.println(Dynamixel.moving(servoID));\n\n  Serial.println(\"------------------------------------------\");\n}\n\n\n\n\nThe terminal's output should look similar to this:\n\n\n\n\nAs you can see the code is relatively simple.\nFirst, include the library into your code:\n\n\n#include <DuoDMXL.h>\n\n\n\n\nThe minimal code for setting up communication is:\n\n\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closes to the TX and RX pins\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid servoIntroduction(unsigned char servoID);  //custom function\n\nvoid setup() {\n  Serial.begin(115200);               //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);     // Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n}\n\n\n\n\nFinally, the loop has to call the custom function \nservoIntroduction()\n continuously:\n\n\nvoid loop() {\n    servoIntroduction(servoID);             //print the information of the servo with ID = servoID\n    delay(1000);                            //wait one second and show the information again\n}",
            "title": "Example 1"
        },
        {
            "location": "/examples/example1/#example-1-reading-the-information-of-your-servo",
            "text": "In this example, general information about the servo (e.g., ID, model, values of several memory registers) is obtained and then displayed on the output of the terminal.  /*\n * Copyright (c) 2016 Fabian Eugenio Reyes Pinner (Fabian Reyes)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n /*\n  * In this example, the information (for example, configured values in its EEPROM or RAM area) of a servo will be obtained and displayed into the terminal.\n  * It is assumed that the ID of the servo is '1' and the baudrate configured is '57600'. This may be different of your setup, so just change the necessary\n  * parameters.\n  */\n\nSYSTEM_MODE(MANUAL);  //do not connect to the cloud. Communicate with the servo immediately\n\n//The DuoDMXL library allows communication with the servo\n#include <DuoDMXL.h>\n\nint led1 = D7;      //onboard LED\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closes to the TX and RX pins\nint servoID = 1;\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid servoIntroduction(unsigned char servoID);  //custom function\n\nvoid setup() {\n  pinMode(led1, OUTPUT);              //prepare the on-board LED\n\n  Serial.begin(115200);               //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);     // Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n\n  delay(1000);                        //Let's wait a little bit\n\n}\n\nvoid loop() {\n\n    digitalWrite(led1, HIGH);               //turn on on-board LED to show that the self-introduction has started\n\n    servoIntroduction(servoID);             //print the information of the servo with ID = servoID\n\n    digitalWrite(led1, LOW);\n\n    delay(1000);                            //wait one second and show the information again\n}\n\n//Basic information about the servo\nvoid servoIntroduction(uint8_t servoID){\n  Serial.println(\"------------------------------------------\");\n\n  Serial.print(\"Hi, I am a servo model \");\n  Serial.print(Dynamixel.readModel(servoID));\n  Serial.print(\" with Firmware version \");\n  Serial.print(Dynamixel.readFirmware(servoID));\n  Serial.print(\", my ID is \");\n  Serial.print(Dynamixel.readID(servoID));\n  Serial.print(\", communicating at a baudrate of \");\n  Serial.print(Dynamixel.readBD(servoID));\n  Serial.print(\", with a RDT of \");\n  Serial.println(Dynamixel.readRDT(servoID));\n\n  Serial.print(\"CW limit set as \");\n  Serial.print(Dynamixel.readCWAngleLimit(servoID));\n  Serial.print(\", CCW limit set as \");\n  Serial.println(Dynamixel.readCCWAngleLimit(servoID));\n\n  Serial.print(\"The temperature limit, lowest voltage limit, highest voltage limit, and max torque are: \");\n  Serial.print(Dynamixel.readTempLimit(servoID));\n  Serial.print(\", \");\n  Serial.print(Dynamixel.readLowVoltageLimit(servoID));\n  Serial.print(\", \");\n  Serial.print(Dynamixel.readHighVoltageLimit(servoID));\n  Serial.print(\", \");\n  Serial.println(Dynamixel.readMaxTorque(servoID));\n\n  Serial.print(\"My Status return level, Alarm LED, and shutdown alarm settings are: \");\n  Serial.print(Dynamixel.readSRL(servoID));\n  Serial.print(\", \");\n  Serial.print(Dynamixel.readAlarmLED(servoID));\n  Serial.print(\", \");\n  Serial.println(Dynamixel.readShutdownAlarm(servoID));\n\n  Serial.print(\"The multi-turn offset setting and resolution divider are: \");\n  Serial.print(Dynamixel.readMultiTurnOffset(servoID));\n  Serial.print(\", \");\n  Serial.println(Dynamixel.readResolutionDivider(servoID));\n\n  Serial.print(\"The DIP gains are: \");\n  Serial.print(Dynamixel.readGainD(servoID));\n  Serial.print(\", \");\n  Serial.print(Dynamixel.readGainI(servoID));\n  Serial.print(\", and \");\n  Serial.println(Dynamixel.readGainP(servoID));\n\n  Serial.print(\"The value of moving speed is: \");\n  Serial.println(Dynamixel.readMovingSpeed(servoID));\n  Serial.print(\"The value of torque limit (goal torque) is: \");\n  Serial.println(Dynamixel.readTorqueLimit(servoID));\n\n  Serial.print(\"My present load is: \");\n  Serial.println(Dynamixel.readLoad(servoID));\n  Serial.print(\"I am operating at a voltage of \");\n  Serial.print(Dynamixel.readVoltage(servoID));\n  Serial.print(\" and a temperature of \");\n  Serial.println(Dynamixel.readTemperature(servoID));\n\n  Serial.print(\"Is there a function waiting to be executed in Registered?: \");\n  Serial.println(Dynamixel.registeredStatus(servoID));\n\n  Serial.print(\"Is a moving (goal_position) command being executed?: \");\n  Serial.println(Dynamixel.moving(servoID));\n\n  Serial.println(\"------------------------------------------\");\n}  The terminal's output should look similar to this:   As you can see the code is relatively simple.\nFirst, include the library into your code:  #include <DuoDMXL.h>  The minimal code for setting up communication is:  int dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closes to the TX and RX pins\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid servoIntroduction(unsigned char servoID);  //custom function\n\nvoid setup() {\n  Serial.begin(115200);               //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);     // Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n}  Finally, the loop has to call the custom function  servoIntroduction()  continuously:  void loop() {\n    servoIntroduction(servoID);             //print the information of the servo with ID = servoID\n    delay(1000);                            //wait one second and show the information again\n}",
            "title": "Example 1 - Reading the information of your servo"
        },
        {
            "location": "/examples/example2/",
            "text": "Example 2 - Moving the servo to a desired position\n\n\nIn this example, the servo is moved to a desired position. It is assumed you know the ID and correct baudrate to communicate with the servo. After moving the servo the \nactual\n position of the servo is displayed on the terminal.\n\n\n/*\n * Copyright (c) 2016 Fabian Eugenio Reyes Pinner (Fabian Reyes)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n /*\n  * In this example, we will move the servo to 0[deg], 180[deg], and finally 360[deg].\n  * Also, we will print the current position to the terminal.\n  *\n  * This example introduces the functions Dynamixel.move() and Dynamixel.readPosition()\n  */\n\nSYSTEM_MODE(MANUAL);  //do not connect to the cloud. Communicate with the servo immediately\n\n//The DuoDMXL library allows communication with the servo\n#include <DuoDMXL.h>\n\nint led1 = D7;      //onboard LED\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closest to the TX and RX pins\nint errorMove, servoPos, servoCurrent, servoTorqueEnableStatus, gainD, gainI, gainP;\nint servoID = 1;\n\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid setup() {\n  pinMode(led1, OUTPUT);                  //prepare the on-board LED\n\n  Serial.begin(115200);                   //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);         //Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n\n  delay(1000);                            //Let's wait a little bit\n\n}\n\nvoid loop() {\n  digitalWrite(led1, HIGH);               //turn on on-board LED to show that the loop has started\n\n  int actualPos;\n\n  //move to 0[deg] (bit-wise value 0)\n  Dynamixel.move(servoID, 0);\n  actualPos = Dynamixel.readPosition(servoID);\n  Serial.print(\"The actual position is: \");\n  Serial.println(actualPos);\n  delay(1000);                            //wait one second\n\n  //move to 180[deg] (bit-wise value 2048)\n  Dynamixel.move(servoID, 2048);\n  actualPos = Dynamixel.readPosition(servoID);\n  Serial.print(\"The actual position is: \");\n  Serial.println(actualPos);\n  delay(1000);                            //wait one second\n\n  //move to 360[deg] (bit-wise value 4095)\n  Dynamixel.move(servoID, 4095);\n  actualPos = Dynamixel.readPosition(servoID);\n  Serial.print(\"The actual position is: \");\n  Serial.println(actualPos);\n  delay(1000);                            //wait one second\n\n  digitalWrite(led1, LOW);\n}\n\n\n\n\nThe output on the terminal should look similar to this:\n\n\n\n\nNext I show the minimal functional code to make the example work. Start by including the library into your code:\n\n\n#include <DuoDMXL.h>\n\n\n\n\nThe minimal code for setting up communication and other information in this example is:\n\n\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closest to the TX and RX pins\nint errorMove, servoPos, servoCurrent, servoTorqueEnableStatus, gainD, gainI, gainP;\nint servoID = 1;\n\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid setup() {\n  Serial.begin(115200);                   //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);         //Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n}\n\n\n\n\nFinally, move the servo to a set of desired positions in a loop. In this minimal code I do not include the output to the terminal or blinking the LED:\n\n\nvoid loop() {\n  int actualPos;\n\n  //move to 0[deg] (bit-wise value 0)\n  Dynamixel.move(servoID, 0);\n  delay(1000);                            //wait one second\n\n  //move to 180[deg] (bit-wise value 2048)\n  Dynamixel.move(servoID, 2048);\n  delay(1000);                            //wait one second\n\n  //move to 360[deg] (bit-wise value 4095)\n  Dynamixel.move(servoID, 4095);\n  delay(1000);                            //wait one second\n}",
            "title": "Example 2"
        },
        {
            "location": "/examples/example2/#example-2-moving-the-servo-to-a-desired-position",
            "text": "In this example, the servo is moved to a desired position. It is assumed you know the ID and correct baudrate to communicate with the servo. After moving the servo the  actual  position of the servo is displayed on the terminal.  /*\n * Copyright (c) 2016 Fabian Eugenio Reyes Pinner (Fabian Reyes)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n /*\n  * In this example, we will move the servo to 0[deg], 180[deg], and finally 360[deg].\n  * Also, we will print the current position to the terminal.\n  *\n  * This example introduces the functions Dynamixel.move() and Dynamixel.readPosition()\n  */\n\nSYSTEM_MODE(MANUAL);  //do not connect to the cloud. Communicate with the servo immediately\n\n//The DuoDMXL library allows communication with the servo\n#include <DuoDMXL.h>\n\nint led1 = D7;      //onboard LED\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closest to the TX and RX pins\nint errorMove, servoPos, servoCurrent, servoTorqueEnableStatus, gainD, gainI, gainP;\nint servoID = 1;\n\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid setup() {\n  pinMode(led1, OUTPUT);                  //prepare the on-board LED\n\n  Serial.begin(115200);                   //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);         //Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n\n  delay(1000);                            //Let's wait a little bit\n\n}\n\nvoid loop() {\n  digitalWrite(led1, HIGH);               //turn on on-board LED to show that the loop has started\n\n  int actualPos;\n\n  //move to 0[deg] (bit-wise value 0)\n  Dynamixel.move(servoID, 0);\n  actualPos = Dynamixel.readPosition(servoID);\n  Serial.print(\"The actual position is: \");\n  Serial.println(actualPos);\n  delay(1000);                            //wait one second\n\n  //move to 180[deg] (bit-wise value 2048)\n  Dynamixel.move(servoID, 2048);\n  actualPos = Dynamixel.readPosition(servoID);\n  Serial.print(\"The actual position is: \");\n  Serial.println(actualPos);\n  delay(1000);                            //wait one second\n\n  //move to 360[deg] (bit-wise value 4095)\n  Dynamixel.move(servoID, 4095);\n  actualPos = Dynamixel.readPosition(servoID);\n  Serial.print(\"The actual position is: \");\n  Serial.println(actualPos);\n  delay(1000);                            //wait one second\n\n  digitalWrite(led1, LOW);\n}  The output on the terminal should look similar to this:   Next I show the minimal functional code to make the example work. Start by including the library into your code:  #include <DuoDMXL.h>  The minimal code for setting up communication and other information in this example is:  int dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closest to the TX and RX pins\nint errorMove, servoPos, servoCurrent, servoTorqueEnableStatus, gainD, gainI, gainP;\nint servoID = 1;\n\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid setup() {\n  Serial.begin(115200);                   //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);         //Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n}  Finally, move the servo to a set of desired positions in a loop. In this minimal code I do not include the output to the terminal or blinking the LED:  void loop() {\n  int actualPos;\n\n  //move to 0[deg] (bit-wise value 0)\n  Dynamixel.move(servoID, 0);\n  delay(1000);                            //wait one second\n\n  //move to 180[deg] (bit-wise value 2048)\n  Dynamixel.move(servoID, 2048);\n  delay(1000);                            //wait one second\n\n  //move to 360[deg] (bit-wise value 4095)\n  Dynamixel.move(servoID, 4095);\n  delay(1000);                            //wait one second\n}",
            "title": "Example 2 - Moving the servo to a desired position"
        },
        {
            "location": "/examples/example3/",
            "text": "Example 3 - Functions related to torque mode\n\n\nIn this example, the servo's torque mode is enabled. Also the torque limit is set.\nA goal torque is then sent to the motor while at the same time we obtian the actual value of the current of the servo.\n\n\n/*\n * Copyright (c) 2016 Fabian Eugenio Reyes Pinner (Fabian Reyes)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n /*\n  * In this example, we will turn on torque control and use it. Notice that, if there is no resistance to the servo motion, it will simply rotate\n  * trying to achieve the desired torque.\n  *\n  * This example introduces the functions Dynamixel.setTorqueLimit(), Dynamixel.torqueControl(), Dynamixel.setGoalTorque(), and Dynamixel.readCurrent()\n  */\n\nSYSTEM_MODE(MANUAL);  //do not connect to the cloud. Communicate with the servo immediately\n\n//The DuoDMXL library allows communication with the servo\n#include <DuoDMXL.h>\n\nint led1 = D7;      //onboard LED\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closest to the TX and RX pins\nint errorMove, servoPos, servoCurrent, servoTorqueEnableStatus, gainD, gainI, gainP;\nint servoID = 1;\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid setup() {\n  pinMode(led1, OUTPUT);                  //prepare the on-board LED\n\n  Serial.begin(115200);                   //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);         //Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n\n  delay(1000);                            //Let's wait a little bit\n\n  Dynamixel.setTorqueLimit(servoID, 1023);  //Set the torque limit to the maximum value possible\n  Dynamixel.torqueControl(servoID, true);   //Enable torque control\n}\n\nvoid loop() {\n  digitalWrite(led1, HIGH);               //turn on on-board LED to show that the loop has started\n\n  int actualCurrent;\n\n  //Ask for 0% torque\n  Dynamixel.setGoalTorque(servoID, 0);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  Serial.print(\"The actual current is: \");\n  Serial.println(actualCurrent);\n  delay(1000);                            //wait one second\n\n  //Ask for 1% torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 10);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  Serial.print(\"The actual current is: \");\n  Serial.println(actualCurrent);\n  delay(1000);                            //wait one second\n\n  //Ask for 5% of torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 51);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  Serial.print(\"The actual current is: \");\n  Serial.println(actualCurrent);\n  delay(1000);                            //wait one second\n\n  //Ask for 10% of torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 102);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  Serial.print(\"The actual current is: \");\n  Serial.println(actualCurrent);\n  delay(1000);                            //wait one second\n\n  digitalWrite(led1, LOW);\n}\n\n\n\n\nThe output on the terminal looks like this:\n\n\nNext I show the minimal functional code to make the example work without output to the terminal. Start by including the library into your code:\n\n\n#include <DuoDMXL.h>\n\n\n\n\nThe minimal code for setting up communication and other information in this example is:\n\n\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closest to the TX and RX pins\nint errorMove, servoPos, servoCurrent, servoTorqueEnableStatus, gainD, gainI, gainP;\nint servoID = 1;\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid setup() {\n  Serial.begin(115200);                   //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);         //Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n\n  delay(1000);                            //Let's wait a little bit\n\n  Dynamixel.setTorqueLimit(servoID, 1023);  //Set the torque limit to the maximum value possible\n  Dynamixel.torqueControl(servoID, true);   //Enable torque control\n}\n\n\n\n\nFinally, set a goal torque. If the motor is not constrained in any way it will start to move continously, trying to reach the desired torque (current).\n\n\nvoid loop() {\n  int actualCurrent;\n\n  //Ask for 0% torque\n  Dynamixel.setGoalTorque(servoID, 0);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  delay(1000);                            //wait one second\n\n  //Ask for 1% torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 10);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  delay(1000);                            //wait one second\n\n  //Ask for 5% of torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 51);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  delay(1000);                            //wait one second\n\n  //Ask for 10% of torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 102);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  delay(1000);                            //wait one second\n}",
            "title": "Example 3"
        },
        {
            "location": "/examples/example3/#example-3-functions-related-to-torque-mode",
            "text": "In this example, the servo's torque mode is enabled. Also the torque limit is set.\nA goal torque is then sent to the motor while at the same time we obtian the actual value of the current of the servo.  /*\n * Copyright (c) 2016 Fabian Eugenio Reyes Pinner (Fabian Reyes)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n /*\n  * In this example, we will turn on torque control and use it. Notice that, if there is no resistance to the servo motion, it will simply rotate\n  * trying to achieve the desired torque.\n  *\n  * This example introduces the functions Dynamixel.setTorqueLimit(), Dynamixel.torqueControl(), Dynamixel.setGoalTorque(), and Dynamixel.readCurrent()\n  */\n\nSYSTEM_MODE(MANUAL);  //do not connect to the cloud. Communicate with the servo immediately\n\n//The DuoDMXL library allows communication with the servo\n#include <DuoDMXL.h>\n\nint led1 = D7;      //onboard LED\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closest to the TX and RX pins\nint errorMove, servoPos, servoCurrent, servoTorqueEnableStatus, gainD, gainI, gainP;\nint servoID = 1;\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid setup() {\n  pinMode(led1, OUTPUT);                  //prepare the on-board LED\n\n  Serial.begin(115200);                   //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);         //Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n\n  delay(1000);                            //Let's wait a little bit\n\n  Dynamixel.setTorqueLimit(servoID, 1023);  //Set the torque limit to the maximum value possible\n  Dynamixel.torqueControl(servoID, true);   //Enable torque control\n}\n\nvoid loop() {\n  digitalWrite(led1, HIGH);               //turn on on-board LED to show that the loop has started\n\n  int actualCurrent;\n\n  //Ask for 0% torque\n  Dynamixel.setGoalTorque(servoID, 0);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  Serial.print(\"The actual current is: \");\n  Serial.println(actualCurrent);\n  delay(1000);                            //wait one second\n\n  //Ask for 1% torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 10);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  Serial.print(\"The actual current is: \");\n  Serial.println(actualCurrent);\n  delay(1000);                            //wait one second\n\n  //Ask for 5% of torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 51);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  Serial.print(\"The actual current is: \");\n  Serial.println(actualCurrent);\n  delay(1000);                            //wait one second\n\n  //Ask for 10% of torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 102);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  Serial.print(\"The actual current is: \");\n  Serial.println(actualCurrent);\n  delay(1000);                            //wait one second\n\n  digitalWrite(led1, LOW);\n}  The output on the terminal looks like this:  Next I show the minimal functional code to make the example work without output to the terminal. Start by including the library into your code:  #include <DuoDMXL.h>  The minimal code for setting up communication and other information in this example is:  int dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closest to the TX and RX pins\nint errorMove, servoPos, servoCurrent, servoTorqueEnableStatus, gainD, gainI, gainP;\nint servoID = 1;\nlong baud = 57600;  //Baudrate for communication with Dynamixel servos (Depending of your servo, this may be 1Mbps by default)\n\nvoid setup() {\n  Serial.begin(115200);                   //Start communication with the PC;\n  Dynamixel.begin(baud, dataPin);         //Initialize the servo at Baud Rate (baud) and Pin Control (dataPin)\n\n  delay(1000);                            //Let's wait a little bit\n\n  Dynamixel.setTorqueLimit(servoID, 1023);  //Set the torque limit to the maximum value possible\n  Dynamixel.torqueControl(servoID, true);   //Enable torque control\n}  Finally, set a goal torque. If the motor is not constrained in any way it will start to move continously, trying to reach the desired torque (current).  void loop() {\n  int actualCurrent;\n\n  //Ask for 0% torque\n  Dynamixel.setGoalTorque(servoID, 0);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  delay(1000);                            //wait one second\n\n  //Ask for 1% torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 10);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  delay(1000);                            //wait one second\n\n  //Ask for 5% of torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 51);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  delay(1000);                            //wait one second\n\n  //Ask for 10% of torque (Counter-clockwise)\n  Dynamixel.setGoalTorque(servoID, 102);\n  actualCurrent = Dynamixel.readCurrent(servoID);\n  delay(1000);                            //wait one second\n}",
            "title": "Example 3 - Functions related to torque mode"
        },
        {
            "location": "/examples/example4/",
            "text": "Example 4 - Finding your servo\n\n\nIf by any chance you don't remember the ID of your servo or the correct baudrate to communicate with it, then the servo is useless.\nHowever, with this function you can find it (connect only one servo to the bus).\nThe servo ID and the baudrate it uses to communicate will be printed on the serial monitor.\nThe baudrate value will be an integer [0,255].\nRefer to the \nROBOTIS manual\n for its equivalent in bps.\n\n\n/*\n * Copyright (c) 2016 Fabian Eugenio Reyes Pinner (Fabian Reyes)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n /*\n  * In this example, we will try to find a servo without knowing its ID nor the correct baudrate for communication.\n  * In this case, you do not neet to use Dynamixel.begin() to start communication.\n  * The results of the search will be printed onto the Serial Monitor.\n  */\n\nSYSTEM_MODE(MANUAL);  //do not connect to the cloud. Communicate with the servo immediately\n\n//The DuoDMXL library allows communication with the servo\n#include <DuoDMXL.h>\n\nint led1 = D7;      //onboard LED\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closest to the TX and RX pins\n\nvoid setup() {\n  pinMode(led1, OUTPUT);                  //prepare the on-board LED\n\n  Serial.begin(115200);                   //Start communication with the PC;\n\n  delay(1000);                            //Let's wait a little bit\n\n}\n\nvoid loop() {\n  digitalWrite(led1, HIGH);               //turn on on-board LED to show that the loop has started\n\n  Dynamixel.findServo(dataPin);           //To start searching for the servo, specify the pinthat controls the direction of communication. By default D15 in Duo (Redbear)\n\n  digitalWrite(led1, LOW);\n}\n\n\n\n\nThe output of the terminal will look like this:\n\n\n\n\nThe servo found has ID \n2\n and the baudrate (table value) is \n34\n.\nAccording to the Robotis manual, this corresponds to 57142.9 bps (often rounded up to 57600 bps).",
            "title": "Example 4"
        },
        {
            "location": "/examples/example4/#example-4-finding-your-servo",
            "text": "If by any chance you don't remember the ID of your servo or the correct baudrate to communicate with it, then the servo is useless.\nHowever, with this function you can find it (connect only one servo to the bus).\nThe servo ID and the baudrate it uses to communicate will be printed on the serial monitor.\nThe baudrate value will be an integer [0,255].\nRefer to the  ROBOTIS manual  for its equivalent in bps.  /*\n * Copyright (c) 2016 Fabian Eugenio Reyes Pinner (Fabian Reyes)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\n\n /*\n  * In this example, we will try to find a servo without knowing its ID nor the correct baudrate for communication.\n  * In this case, you do not neet to use Dynamixel.begin() to start communication.\n  * The results of the search will be printed onto the Serial Monitor.\n  */\n\nSYSTEM_MODE(MANUAL);  //do not connect to the cloud. Communicate with the servo immediately\n\n//The DuoDMXL library allows communication with the servo\n#include <DuoDMXL.h>\n\nint led1 = D7;      //onboard LED\nint dataPin = D15;  //Pin used to control Data flow between the DUO and Dynamixel. By default we use the D15 Pin which is closest to the TX and RX pins\n\nvoid setup() {\n  pinMode(led1, OUTPUT);                  //prepare the on-board LED\n\n  Serial.begin(115200);                   //Start communication with the PC;\n\n  delay(1000);                            //Let's wait a little bit\n\n}\n\nvoid loop() {\n  digitalWrite(led1, HIGH);               //turn on on-board LED to show that the loop has started\n\n  Dynamixel.findServo(dataPin);           //To start searching for the servo, specify the pinthat controls the direction of communication. By default D15 in Duo (Redbear)\n\n  digitalWrite(led1, LOW);\n}  The output of the terminal will look like this:   The servo found has ID  2  and the baudrate (table value) is  34 .\nAccording to the Robotis manual, this corresponds to 57142.9 bps (often rounded up to 57600 bps).",
            "title": "Example 4 - Finding your servo"
        },
        {
            "location": "/examples/tests/",
            "text": "Here I present a few tests of the performance of \nDuoDMXL\n.\nThe following picture shows the output of the logic analyzer when writing the package \n{0xFF,0xFF,0x01,0x04,0x02,0x03,0x01,0xF4}\n which reads the address 0x03 of the servo's EEPROM area.\nIn other words, it reads the servo's ID.\n\n\n\n\nWhen communicating with an MX-64AR servomotor connected to the RS-485 bus, using an oscillocope to measure the output on the D+ and D- lines is:\n\n\n\n\n\n\nIn both tests, the baudrate used was 57600 bps.",
            "title": "Tests"
        },
        {
            "location": "/about/",
            "text": "About this Library\n\n\nThis site provides documentation for the library \nDuoDMXL\n intended for communicating a Duo (RedBear) microcontroller board with DYNAMIXEL servomotors.\nThe library was designed with servos MX-64AR as its main target so it may need some modifications for other models.\n\n\nAdditionally, schematics and board designs are provided for faster prototyping.\n\n\nContact information\n\n\nIf you have any question contact me through the \nGitHub repository\n or to my e-mail address:\n\nbugundianvolker@gmail.com\n.\n\n\n\n\nImage by \nernestdesigns",
            "title": "About"
        },
        {
            "location": "/about/#about-this-library",
            "text": "This site provides documentation for the library  DuoDMXL  intended for communicating a Duo (RedBear) microcontroller board with DYNAMIXEL servomotors.\nThe library was designed with servos MX-64AR as its main target so it may need some modifications for other models.  Additionally, schematics and board designs are provided for faster prototyping.",
            "title": "About this Library"
        },
        {
            "location": "/about/#contact-information",
            "text": "If you have any question contact me through the  GitHub repository  or to my e-mail address: bugundianvolker@gmail.com .   Image by  ernestdesigns",
            "title": "Contact information"
        }
    ]
}